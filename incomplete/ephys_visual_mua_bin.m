function [MUA TIME LABEL HISTOGRAM]=ephys_visual_mua_bin(MIC_DATA,EPHYS_DATA,CHANNELS,varargin)
%%this function is incomplete, use at your own risk
%
%intan_visual_mua.m takes data generated by intan_cluster.m and stored in extracted_data.mat
%and produces song_aligned multi-unit rasters.
%
%	[MUA TIME LABEL HISTOGRAM]=ephys_visual_mua_bin(MIC_DATA,EPHYS_DATA,CHANNELS,varargin)
%
%	MIC_DATA
%	aligned microphrone traces from extracted_data.mat (should be the variable mic_data)
%
%	EPHYS_DATA
%	aligned Intan data from extracted_data.mat (should be the variable ephys_data)
%
%	CHANNELS
%	channel labels (i.e. the channel that corresponds to a given element in the cell array
%	ephys_data) from extracted_data.mat
%
%	the following may be specified as parameter/value pairs:
%
%		exclude
%		electrodes to exclude from noise estimate
%
%		smooth_window
%		smoothing_window for multi-unit in seconds (default .005)
%
%		SR
%		data sampling rate (default: 25e3)
%
%		noise
%		noise rejection method (default: 'car', or common-average-rejection)
%
%		filtering
%		define as a two-element vector with lower and upper corner frequencies 
%		to filtering multi-unit traces (default: none)
%
%		dir
%		directory to store results (default: pwd)
%
%		min_f
%		lowermost frequency to display for contour histogram
%
%		max_f
%		uppermost frequency to display for contour histogram
%
%		colors
%		colormap for contour histogram and multi-unit data
%
%

if nargin<3 | isempty(CHANNELS), CHANNELS=1:16; end

nparams=length(varargin);

if mod(nparams,2)>0
	error('Parameters must be specified as parameter/value pairs');
end

%%%

sigma=.0025; % smoothing window in secs
SR=25e3;
preproc='square'; % square or abs?
noise='car'; % common-average reference for noise removal
exclude=[];
smoothing='y';
filtering='y'; % if defined then filtering filter the traces
dir=pwd;
min_f=1e3;
max_f=10e3;
hist_colors='jet';
mua_colors='bone';
figtitle='';
freq_range=[500 5e3]; % frequency range for filtering
downsampling=2;
channels=CHANNELS;
noisereject=1e3;
bininterval=1;

for i=1:2:nparams
	switch lower(varargin{i})
		case 'sigma'
			smooth_window=varargin{i+1};
		case 'sr'
			SR=varargin{i+1};
		case 'preproc'
			preproc=varargin{i+1};
		case 'noise'
			noise=varargin{i+1};
		case 'filtering'
			filtering=varargin{i+1};
		case 'dir'
			dir=varargin{i+1};
		case 'min_f'
			min_f=varargin{i+1};
		case 'max_f'
			max_f=varargin{i+1};
		case 'mua_colors'
			mua_colors=varargin{i+1};
		case 'hist_colors'
			hist_colors=varargin{i+1};
		case 'exclude'
			exclude=varargin{i+1};
		case 'figtitle'
			figtitle=varargin{i+1};
		case 'freq_range'
			freq_range=varargin{i+1};
		case 'downsampling'
			downsampling=varargin{i+1};
		case 'channels'
			channels=varargin{i+1};
		case 'noisereject'
			noisereject=varargin{i+1};
		case 'bininterval'
			bininterval=varargin{i+1};
	end
end

% perhaps add a median filter here to remove spikes from the multi-unit trace

% intan nearest neighbor mapping

channel_map=[4 3 2 1 16 15 14 13 5 6 7 8 9 10 11 12];
channel_ref=[3 4 3 2 1 16 15 14 6 5 6 7 8 9 10 11];

% kernel for smoothing multi-unit, just use a Gauss here...

edges=[-3*sigma:1/SR:3*sigma];
kernel=(1/(sigma*sqrt(2*pi)))*exp((-(edges-0).^2)./(2*sigma^2));
kernel=kernel./sum(kernel); % normalize to sum to 1

% what to exclude from CAR?

% need to write a function for automatically determining which electrodes to reject

exclude_channels=[];

for i=1:length(exclude)
	exclude_channels(i)=find(CHANNELS==exclude(i));
end

electrodes=setdiff(1:length(CHANNELS),exclude_channels); % which electrodes are good?

if max_f>SR/2
	disp('Maximum Fs must be less than Nyquist!');
	disp('Resetting max fs');
	max_f==SR/2;
end

[samples,ntrials,nelectrodes]=size(EPHYS_DATA);
TIME=[1:samples]./SR;
LABEL=CHANNELS;

disp('Referencing and filtering...');

switch lower(noise)
	case 'car'

		car=mean(EPHYS_DATA,3);
		raster_fig=figure('Visible','off');
		imagesc(TIME,1:ntrials,car');
		colormap(mua_colors);
		%multi_fig_save(raster_fig,dir,[ 'CAR' ],'png');
		close([raster_fig]);

		for i=1:length(CHANNELS)
			EPHYS_DATA(:,:,i)=EPHYS_DATA(:,:,i)-car;
		end

	case 'nn'

		for i=1:length(CHANNELS)
			EPHYS_DATA(:,:,i)=EPHYS_DATA(:,:,i)-EPHYS_DATA(:,:,find(channel_map==i));
		end

end

for i=1:length(CHANNELS)

	disp(['Electrode ' num2str(CHANNELS(i))]);

	for j=1:ntrials

		if lower(filtering(1))=='y'

			[b,a]=butter(2,[freq_range]./(SR/2));
			EPHYS_DATA(:,j,i)=single(filtfilt(b,a,double(EPHYS_DATA(:,j,i))));
		
		end
		
	end

	
end

switch lower(preproc)
	case 'square'
		EPHYS_DATA=EPHYS_DATA.^2;
	case 'abs'
		EPHYS_DATA=abs(EPHYS_DATA);
	otherwise
end

% any trials to delete?

disp('Generating contour histogram...');

[HISTOGRAM.rmask HISTOGRAM.imask HISTOGRAM.f HISTOGRAM.t]=...
	contour_histogram(MIC_DATA,'sr',SR,'tscale',1.5);

startidx=max([find(HISTOGRAM.f<=min_f)]);
stopidx=min([find(HISTOGRAM.f>=max_f)]);

mean_osc=mean(MIC_DATA,2);
clear MIC_DATA;

% are we downsampling

if ~isempty(downsampling)
	MUA.t=downsample(TIME,downsampling);
end

disp('Converting to raster form...');

MUA.image=zeros(ntrials,length(MUA.t),length(channels),'single');
MUA.trials=1:ntrials;

% need a noise cutoff...

for i=1:length(channels)
	channels(i)=find(channels(i)==CHANNELS);
end

switch lower(smoothing(1))
	case 'y'
		for i=1:length(channels)
			disp(['Electrode ' num2str(channels(i))]);
			for j=1:ntrials
				MUA.image(j,:,i)=downsample(conv(EPHYS_DATA(:,j,channels(i)),kernel,'same'),downsampling);
				MUA.image(j,:,i)=prctile_bin(MUA.image(j,:,i),bininterval);
			end
		end		

	otherwise

		% just downsample

end

disp('Generating figures...');
disp(['Will save to directory:  ' dir]);

% scale pixels by time

if ~exist(fullfile(dir,'mua_bin'),'dir')
	mkdir(fullfile(dir,'mua_bin'));
end

for i=1:length(channels)

	ax=[];
	raster_fig=figure('visible','off','Units','Pixels','Position',[0 0 1e3 1.4e3]);

	ax(1)=subaxis(6,1,1,1,1,2,'margin',.1,'spacingvert',0);
	imagesc(HISTOGRAM.t,HISTOGRAM.f(startidx:stopidx),HISTOGRAM.imask(startidx:stopidx,:));
	colormap(hist_colors);
	freezeColors;
	set(gca,'ydir','normal','tickdir','out','xtick',[],'ytick',[min_f max_f],'linewidth',1.5,'ticklength',[.025 .025],...
		'FontSize',16,'FontName','Helvetica');
	ylim([min_f max_f]);
	box off;
	title({[ figtitle ];[ 'Channel ' num2str(LABEL(i))]},'FontSize',18,'FontName','Helvetica');

	ax(2)=subaxis(6,1,1,3,1,1,'spacingvert',0,'margin',0.1,'paddingbottom',.025);
	plot(TIME,mean_osc,'-k');
	ylabel('Osc.','FontSize',20,'FontName','Helvetica');
	axis tight;
	set(gca,'tickdir','out','xtick',[],'ytick',[]);

	% any trials to exclude?

	reject=hampel_filter(MUA.image(:,:,i)','hampel_factor',3);
	goodtrials=setdiff(MUA.trials,reject);

	ax(3)=subaxis(6,1,1,4,1,3,'spacingvert',0.025,'margin',0.1,'paddingbottom',0);
	imagesc(MUA.t,MUA.trials(goodtrials),MUA.image(goodtrials,:,i));
	axis tight;
	colormap(mua_colors);
	freezeColors;
	%plot(t,data(:,channelvis(i))-mean(data,2));
	ylabel('Hz');
	xlabel('Time (in s)','FontSize',13,'FontName','Helvetica');
	ylabel('Trial','FontSize',13,'FontName','Helvetica');
	box off
	set(gca,'tickdir','out','linewidth',1.5,'ticklength',[.025 .025],'FontSize',11,'FontName','Helvetica');

	linkaxes(ax,'x');

	[path,name,ext]=fileparts(dir);

	if ~isempty(figtitle)
		name=figtitle;
	end

	set(raster_fig,'PaperPositionMode','auto')

	multi_fig_save(raster_fig,fullfile(dir,'mua_bin'),...
		[ name '_mua_freqrange_' num2str(freq_range) '_electrode_' num2str(CHANNELS(channels(i)))],'eps,png');
	close([raster_fig]);

end

save(fullfile(dir,'mua_bin','mua.mat'),'MUA','LABEL','TIME','HISTOGRAM','EPHYS_DATA','freq_range','channels');

