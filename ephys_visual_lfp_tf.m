function [SPECT_AVE]=ephys_visual_lfp_tf(EPHYS_DATA,HISTOGRAM,CHANNELS,varargin)
%generates a song-aligned average spectrogram of the LFP
%
%	[LFP_RASTER TIME LABEL HISTOGRAM]=ephys_visual_lfp_tf(EPHYS_DATA,HISTOGRAM,CHANNELS,varargin)
%
%	EPHYS_DATA
%	aligned ephys data generated by ephys_cluster or in extracted_data/aggregated_data.mat
%	(should be the variable ephys_data), the data should be a matrix of doubles that is 
%	samples x trials x channels
%
%	HISTOGRAM
%	contour histogram returned by ephys_visual_histogram.m (or loaded from histogram.mat)
%
%	CHANNELS
%	channel labels (i.e. the channel that corresponds to a given element in the cell array
%	ephys_data) from ephys_cluster.m or extracted_data/aggregated_data.mat
%
%	the following may be specified as parameter/value pairs:
%
%		car_exclude
%		electrodes to exclude from noise estimate
%
%		fs
%		data sampling rate (default: 25e3)
%
%		noise
%		noise rejection method ('car' for common average 'nn' for nearest neighbor, or 'none',
%		default: 'none')
%
%		freq_range
%		vector with two elements to specify the frequency range (one element specifies low pass, default: 300)
%
%		savedir
%		directory to store results (default: pwd)
%
%		hist_min_f
%		lowermost frequency to display for contour histogram (default: 1e3)
%
%		hist_max_f
%		uppermost frequency to display for contour histogram (default: 10e3)
%
%		lfp_min_f
%		lowermost frequency to display for contour histogram (default: 1)
%
%		lfp_max_f
%		uppermost frequency to display for contour histogram (default: 100)
%
%		scale
%		scale for LFP spectrogram amplitude (linear or log, default: log)
%
%		lfp_colors
%		colormap (string) for lfp data (default: jet)
%
%		hist_colors
%		colormap(string) for histogram (default: jet)
%
%		medfilt_scale
%		timescale for median filter (in ms, leave blank to skip, default: 1.5)
%
%		method
%		method for computing the LFP spectrogram ('raw' for single Hanning taper or 'mt' for 
%		multi-taper using Slepian functions, default: mt)
%
%		lfp_nfft
%		nfft for lfp spectrogram (default: 10e3)
%
%		lfp_n
%		window size for lfp spectrogram (default: 6250)
%
%		lfp_overlap
%		overlap for lfp spectrogram (default: 6000)
%
%		lfp_w
%		bandwidth for multi-taper (default: 2)
%
%		lfp_ntapers
%		override default number of tapers (leave blank for default, default: 2*w-1)
%
%		singletrials
%		number of single trial spectrograms to plot
%
%		padding
%		zero pads to add to the beginning and end of LFP signal (in seconds, leave empty for no pad default: [])
%
% see also ephys_visual_sua.m,ephys_visual_lfp_amp.m,ephys_visual_mua.m,ephys_visual_lfp_tf_contour.m,time_frequency_raster.m


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PARAMETER COLLECTION %%%%%%%%%%%%%%%%%


if nargin<3
	error('ephysPipeline:lfptfvis:notenoughparams','Need 3 arguments to continue, see documentation');
end

nparams=length(varargin);

if mod(nparams,2)>0
	error('ephysPipeline:argChk','Parameters must be specified as parameter/value pairs!');
end

fs=25e3;
noise='none'; % common-average reference for noise removal
car_exclude=[];
savedir=pwd;
hist_colors='jet';
lfp_colors='jet';
lfp_min_f=1; % bring down to 1
lfp_max_f=100;
lfp_n=500; % defined frequency resolution
lfp_overlap=495;
lfp_nfft=1024; % superficial, makes the spectrogram smoother
lfp_w=2; % time bandwidth product if using multi-taper
lfp_ntapers=[]; % number of tapers, leave blank to use 2*w-1
proc_fs=1250;

hist_min_f=1;
hist_max_f=10e3;

figtitle=[];
freq_range=[5 100]; % frequency range for filtering
filt_order=5;
channels=CHANNELS;
method='raw'; % raw or mt for multi-taper
scale='log';
scalelabel='dB';
singletrials=0;
clipping=-35;
medfilt_scale=3; % median filter scale (in ms)

padding=.12;

for i=1:2:nparams
	switch lower(varargin{i})
		case 'fs'
			fs=varargin{i+1};
		case 'savedir'
			savedir=varargin{i+1};
		case 'hist_colors'
			hist_colors=varargin{i+1};
		case 'car_exclude'
			car_exclude=varargin{i+1};
		case 'figtitle'
			figtitle=varargin{i+1};
		case 'freq_range'
			freq_range=varargin{i+1};
		case 'filt_order'
			filt_order=varargin{i+1};
		case 'channels'
			channels=varargin{i+1};
		case 'method'
			method=varargin{i+1};
		case 'noise'
			noise=varargin{i+1};
		case 'lfp_ntapers'
			lfp_ntapers=varargin{i+1};
		case 'lfp_w'
			lfp_w=varargin{i+1};
		case 'scale'
			scale=varargin{i+1};
		case 'singletrials'
			singletrials=varargin{i+1};
		case 'lfp_min_f'
			lfp_min_f=varargin{i+1};
		case 'lfp_max_f'
			lfp_max_f=varargin{i+1};
		case 'lfp_colors'
			lfp_colors=varargin{i+1};
		case 'lfp_n'
			lfp_n=varargin{i+1};
		case 'lfp_nfft'
			lfp_nfft=varargin{i+1};
		case 'lfp_overlap'
			lfp_overlap=varargin{i+1};
		case 'proc_fs'
			proc_fs=varargin{i+1};
		case 'padding'
			padding=varargin{i+1};
		case 'clipping'
			clipping=varargin{i+1};
	end
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SIGNAL CONDITIONING %%%%%%%%%%%%%%%%

% denoise and condition the signal

[nsamples,ntrials,nchannels]=size(EPHYS_DATA);

% add a zero padd on either side if requested by the user


if ~isempty(padding)
	padsamples=padding*fs;
	pad=zeros(padsamples,ntrials,nchannels);
	EPHYS_DATA=[pad;EPHYS_DATA;pad];
end

downfact=fs/proc_fs;

if mod(downfact,1)>0
	error('ephysPipeline:spectcoherence:downsamplenotinteger','Need to downsample by integer');
end

proc_data=ephys_denoise_signal(EPHYS_DATA,CHANNELS,channels,'method',noise,'car_exclude',car_exclude);

[b,a]=butter(2,[200/(fs/2)],'low');

for i=1:size(proc_data,3)
	proc_data(:,:,i)=filtfilt(b,a,double(proc_data(:,:,i)));
end

proc_data=downsample(proc_data,downfact);

size(proc_data)

proc_data=ephys_condition_signal(proc_data,'l','freq_range',freq_range,'medfilt_scale',medfilt_scale,'medfilt',1,...
	'fs',proc_fs,'filt_order',filt_order);
proc_data=squeeze(proc_data);
clear EPHYS_DATA;

[nsamples,ntrials,nchannels]=size(proc_data);

% get rows and columns

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% get processing parameters

if lfp_n>nsamples
	difference=lfp_n-lfp_overlap;
	lfp_n=round(nsamples/5);
	lfp_overlap=lfp_n-1;

	if lfp_overlap<1
		error('ephysPipeline:lfptf:badparameters','Check window size and overlap');
	end

	warning('ephysPipeline:lfptf:notenoughsamples',...
		'Window size larger than the number of samples, settings window size to %d and ond overlap to %d',lfp_n,lfp_overlap);
end

% if nfft is empty set to nextpow2

if isempty(lfp_nfft)
	lfp_nfft=max([n 2^nextpow2(lfp_n)]);
else
	lfp_nfft=2^nextpow2(lfp_nfft);
end

% check if we're using multi-taper

if lower(method(1))=='m'
	resolution=lfp_w*1/(lfp_n/proc_fs);
	
	if isempty(lfp_ntapers)
		lfp_ntapers=2*(lfp_w)-1;
	end

	[tapers,lambda]=dpss(lfp_n,lfp_w,lfp_ntapers);
else
	lfp_ntapers='';
	resolution=proc_fs/lfp_n;
	tapers=[];
end

disp(['Resolution:  ' num2str(resolution)  ' Hz']);
disp(['NFFT:  ' num2str(lfp_nfft)]);

[t,f,lfp_startidx,lfp_stopidx]=getspecgram_dim(nsamples,lfp_n,lfp_overlap,lfp_nfft,proc_fs,lfp_min_f,lfp_max_f);

if ~isempty(padding)
	t=t-padding;
end
rows=length(f);
columns=length(t);

SPECT_AVE.t=t;
SPECT_AVE.f=f;
SPECT_AVE.image=zeros(length(f),length(t),length(channels),'single');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PLOTTING CODE %%%%%%%%%%%%%%%%%%%%%%

% create output directory

[path,name,ext]=fileparts(savedir);
savedir=fullfile(savedir,'lfp_tf');

switch lower(method(1))

	case 'r'
		savedir=fullfile(savedir,'spectrogram');

	case 'm'
		
		savedir=fullfile(savedir,'slepian');
end


if ~exist(savedir,'dir')
	mkdir(fullfile(savedir));
end

% single trials go in a subdir

savefilename=[ name '_lfptf_electrode_'];

delete(fullfile(savedir,[savefilename '*']));

if exist(fullfile(savedir,'singletrials'));
	rmdir(fullfile(savedir,'singletrials'),'s');
end

for i=1:length(channels)

	savedir_st=fullfile(savedir,'singletrials',[ 'ch' num2str(channels(i))]);

	if ~exist(savedir_st,'dir')
		mkdir(savedir_st);
	end
	
	spect_ave_tmp=zeros(rows,columns);

	parfor j=1:ntrials
	
		currdata=proc_data(:,j,i);
		spect=[];

		switch lower(method(1))
			case 'r'

				[spect]=spectrogram(currdata,lfp_n,lfp_overlap,lfp_nfft);

			case 'm'
				% average over tapers

				spect=zeros(rows,columns);

				for k=1:lfp_ntapers

					spect_tmp=spectrogram(currdata,tapers(:,k),lfp_overlap,lfp_nfft);
					
					% reduce instead to save memory

					spect=spect+spect_tmp./lfp_ntapers;

				end
			
			otherwise

				error('Did not understand method!');

			
		end

		% reduction to save memory, storing in a large matrix probably not viable for large n...
		
		spect_ave_tmp=spect_ave_tmp+spect./ntrials;
		
	end

	SPECT_AVE.data(:,:,i)=spect_ave_tmp; % for saving

	% normalize 

	spectimage=abs(spect_ave_tmp)./max(abs(spect_ave_tmp(:)));

	if strcmp(lower(scale),'log') 
		
		spectimage=20*log10(spectimage);

		if ~isempty(clipping)
			spectimage=max(spectimage,clipping);
		end

	end
		
	spect_ave_plot.image=spectimage; % normalize so max is 0 db
	spect_ave_plot.t=SPECT_AVE.t;
	spect_ave_plot.f=SPECT_AVE.f;

	spect_fig=figure('visible','off','Units','Pixels','Position',[0 0 round(300*nsamples/proc_fs) 800]);
	
	fig_title=['CH' num2str(channels(i)) ' NTAP' num2str(lfp_ntapers) ' RES ' num2str(resolution) ' Hz' ' NTRIALS' num2str(ntrials)];

	spect_fig=time_frequency_raster(HISTOGRAM,spect_ave_plot,'fig_num',spect_fig,'fig_title',fig_title,'scale','linear',...
		'scalelabel',scalelabel,'hist_min_f',hist_min_f,'hist_max_f',hist_max_f,'tf_min_f',lfp_min_f,'tf_max_f',lfp_max_f,...
		'hist_colors',hist_colors,'tfimage_colors',lfp_colors);

	set(spect_fig,'PaperPositionMode','auto');

	multi_fig_save(spect_fig,savedir,...
		[ savefilename num2str(channels(i)) ],'png','res',100);
	close([spect_fig]);

end

save(fullfile(savedir,'lfp_tf_data.mat'),'CHANNELS','channels','SPECT_AVE');

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PARFOR SAVING %%%%%%%%%%%%%%%%%%%%%%

function parsave(FILE,t,f,spect)
	
save(FILE,'t','f','spect');

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



