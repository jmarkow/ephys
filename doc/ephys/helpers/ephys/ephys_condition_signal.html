<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ephys_condition_signal</title>
  <meta name="keywords" content="ephys_condition_signal">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../menu.html">Home</a> &gt;  <a href="../../menu.html">ephys</a> &gt; <a href="../menu.html">helpers</a> &gt; <a href="menu.html">ephys</a> &gt; ephys_condition_signal.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../menu.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="menu.html">Index for ephys/helpers/ephys&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>ephys_condition_signal
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function EPHYS_DATA=ephys_condition_signal(EPHYS_DATA,DATA_TYPE,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../ephys/ephys_pipeline_quicklook.html" class="code" title="function ephys_quicklook(MIC_DATA,EPHYS_DATA,CHANNELS,varargin)">ephys_pipeline_quicklook</a>	ephys_quicklook.m generates a figure to glance at data extracted by the pipeline</li><li><a href="../../../ephys/ephys_su_lfp_coherence_spect.html" class="code" title="function ephys_su_lfp_coherence_spect(LFPCHANNEL,SUCHANNEL,SUCLUSTER,varargin)">ephys_su_lfp_coherence_spect</a>	ephys_su_lfp_coherence_tf computes coherency spectra between LFPs and point processes using the</li><li><a href="../../../ephys/ephys_su_lfp_coherence_tf.html" class="code" title="function [abscoh,t,f]=ephys_su_lfp_coherence_tf(LFPCHANNEL,SUCHANNEL,SUCLUSTER,HISTOGRAM,varargin)">ephys_su_lfp_coherence_tf</a>	ephys_su_lfp_coherence_tf computes coherograms between LFPs and point processes using the</li><li><a href="../../../ephys/ephys_visual_lfp_amp.html" class="code" title="function [LFP_RASTER TIME LABEL HISTOGRAM]=ephys_lfp_amp(EPHYS_DATA,HISTOGRAM,CHANNELS,varargin)">ephys_visual_lfp_amp</a>	ephys_lfp_amp.m takes data generated by ephys_cluster.m and stored in extracted_data.mat</li><li><a href="../../../ephys/ephys_visual_lfp_tf.html" class="code" title="function [SPECT_AVE]=ephys_visual_lfp_tf(EPHYS_DATA,HISTOGRAM,CHANNELS,varargin)">ephys_visual_lfp_tf</a>	ephys_lfp_tf.m takes data generated by ephys_cluster.m and stored in extracted_data.mat</li><li><a href="../../../ephys/ephys_visual_mua.html" class="code" title="function [MUA TIME LABEL HISTOGRAM]=ephys_visual_mua(EPHYS_DATA,HISTOGRAM,CHANNELS,varargin)">ephys_visual_mua</a>	intan_visual_mua.m takes data generated by intan_cluster.m and stored in extracted_data.mat</li><li><a href="../../../ephys/ephys_visual_sua.html" class="code" title="function ephys_visual_sua(EPHYS_DATA,HISTOGRAM,CHANNELS,varargin)">ephys_visual_sua</a>	ephys_visual_sua.m takes data generated by intan_cluster.m and stored in extracted_data.mat</li><li><a href="../../../ephys/helpers/stats/ephys_su_lfp_coherence_quickplots.html" class="code" title="function ephys_su_lfp_coherence_quickplots(LFPCHANNEL,SUCHANNEL,SUCLUSTER,varargin)">ephys_su_lfp_coherence_quickplots</a>	</li><li><a href="../../../ephys/pipeline/ephys_pipeline_candidate_su.html" class="code" title="function SNR=ephys_candidate_su(EPHYS_DATA,CHANNELS,varargin)">ephys_pipeline_candidate_su</a>	ephys_candidate_su.m approximates the SNR of channels by</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function EPHYS_DATA=ephys_condition_signal(EPHYS_DATA,DATA_TYPE,varargin)</a>
0002 <span class="comment">%</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%</span>
0007 
0008 <span class="comment">% filter the data appropriately, single unit, multi unit or LFPs</span>
0009 
0010 <span class="comment">% global defaults</span>
0011 
0012 SR=25e3;
0013 medfilt_scale=1.5; <span class="comment">% median filter scale (in ms)</span>
0014 filt_order=2;
0015 sigma=.0025; <span class="comment">% sigma for Gaussian smoothing kernel (in s)</span>
0016 
0017 <span class="comment">% for now simple butterworth filters, could add support for Kaiser filters</span>
0018 <span class="comment">% per Logothetis et al. 2001</span>
0019 
0020 <span class="comment">% data type specific defaults</span>
0021 
0022 <span class="keyword">switch</span> lower(DATA_TYPE)
0023     
0024     <span class="keyword">case</span> <span class="string">'s'</span>
0025 
0026         <span class="comment">% single unit data</span>
0027 
0028         freq_range=[500 8e3]; <span class="comment">% 500 Hz high pass 8e3 low pass</span>
0029         filt_order=2;
0030         filt_type=<span class="string">'bandpass'</span>;
0031 
0032         <span class="comment">% do not de-mean,trend or median filter!</span>
0033 
0034         filtering=1;
0035         demean=0;
0036         detrenddata=0;
0037         medfilt=0;
0038         rectify=0;
0039         smoothdata=0;
0040 
0041 
0042     <span class="keyword">case</span> <span class="string">'m'</span>
0043 
0044         <span class="comment">% multi unit data</span>
0045         
0046         freq_range=[500 5e3]; <span class="comment">%5-5k bandpass</span>
0047         filt_order=2;
0048         filt_type=<span class="string">'bandpass'</span>;
0049 
0050         filtering=1;
0051         demean=0;
0052         detrenddata=0;
0053         medfilt=0;
0054         rectify=1;
0055         smoothdata=1;
0056 
0057 
0058 
0059     <span class="keyword">case</span> <span class="string">'l'</span>
0060 
0061         <span class="comment">% lfp</span>
0062 
0063         freq_range=[300]; <span class="comment">% 300 Hz low pass</span>
0064         filt_order=2;
0065         filt_type=<span class="string">'low'</span>;
0066 
0067         filtering=1;
0068         demean=1;
0069         detrenddata=1;
0070         medfilt=1;
0071         rectify=0;
0072         smoothdata=0;
0073 
0074 
0075 <span class="keyword">end</span>
0076 
0077 nparams=length(varargin);
0078 
0079 <span class="keyword">if</span> mod(nparams,2)&gt;0
0080     error(<span class="string">'Parameters must be specified as parameter/value pairs'</span>);
0081 <span class="keyword">end</span>
0082 
0083 <span class="comment">% overrides</span>
0084 
0085 <span class="keyword">for</span> i=1:2:nparams
0086     <span class="keyword">switch</span> lower(varargin{i})
0087         <span class="keyword">case</span> <span class="string">'sr'</span>
0088             SR=varargin{i+1};
0089         <span class="keyword">case</span> <span class="string">'freq_range'</span>
0090             freq_range=varargin{i+1};
0091         <span class="keyword">case</span> <span class="string">'filt_type'</span>
0092             filt_type=varargin{i+1};
0093         <span class="keyword">case</span> <span class="string">'filt_order'</span>
0094             filt_order=varargin{i+1};
0095         <span class="keyword">case</span> <span class="string">'demean'</span>
0096             demean=varargin{i+1};
0097         <span class="keyword">case</span> <span class="string">'detrenddata'</span>
0098             detrenddata=varargin{i+1};
0099         <span class="keyword">case</span> <span class="string">'rectify'</span>
0100             rectify=varargin{i+1};
0101         <span class="keyword">case</span> <span class="string">'smoothdata'</span>
0102             smoothdata=varargin{i+1};
0103         <span class="keyword">case</span> <span class="string">'medfilt'</span>
0104             medfilt=varargin{i+1};
0105         <span class="keyword">case</span> <span class="string">'medfilt_scale'</span>
0106             medfilt_scale=varargin{i+1};
0107     <span class="keyword">end</span>
0108 <span class="keyword">end</span>
0109 
0110 <span class="keyword">if</span> length(freq_range)&gt;1
0111     filt_type=<span class="string">'bandpass'</span>;
0112 <span class="keyword">end</span>
0113 
0114 <span class="comment">% if median filtering, this comes first</span>
0115 
0116 <span class="comment">% make sure EPHYS_DATA is a double, otherwise filtering will</span>
0117 <span class="comment">% bail on us</span>
0118 
0119 
0120 [nsamples,ntrials,nchannels]=size(EPHYS_DATA);
0121 
0122 <span class="comment">% cast data type if necessary</span>
0123 
0124 <span class="keyword">if</span> ~isa(EPHYS_DATA,<span class="string">'double'</span>)
0125     EPHYS_DATA=double(EPHYS_DATA);
0126 <span class="keyword">end</span>
0127 
0128 <span class="comment">% order of operations:</span>
0129 <span class="comment">% 1) median filter to remove spikes if necessary (usually LFP only)</span>
0130 <span class="comment">% 2) demean/detrend (usually LFP only)</span>
0131 <span class="comment">% 3) filter to desired frequency range</span>
0132 <span class="comment">% 4) rectify (usually MU only)</span>
0133 <span class="comment">% 5) smooth with a Gaussian kernel (usually MU only)</span>
0134 
0135 <span class="comment">% usually only median filter the signal if we're computing fields, a timescale of ~1.5 ms</span>
0136 <span class="comment">% seems to do a good job of removing spikes</span>
0137 
0138 
0139 <span class="keyword">if</span> medfilt    
0140 
0141     disp([<span class="string">'Median filtering, timescale:  '</span> num2str(medfilt_scale) <span class="string">' ms'</span>]);
0142 
0143     medfilt_order=round(medfilt_scale/1e3*SR);
0144 
0145     <span class="keyword">for</span> i=1:nchannels
0146         parfor j=1:ntrials
0147             EPHYS_DATA(:,j,i)=medfilt1(EPHYS_DATA(:,j,i),medfilt_order);
0148         <span class="keyword">end</span>
0149     <span class="keyword">end</span>
0150 <span class="keyword">end</span>
0151 
0152 <span class="comment">% demean</span>
0153 
0154 <span class="keyword">if</span> demean
0155 
0156     disp(<span class="string">'Demeaning data...'</span>);
0157 
0158     <span class="keyword">for</span> i=1:nchannels
0159         <span class="keyword">for</span> j=1:ntrials
0160             EPHYS_DATA(:,j,i)=EPHYS_DATA(:,j,i)-mean(EPHYS_DATA(:,j,i));
0161         <span class="keyword">end</span>
0162     <span class="keyword">end</span>
0163 <span class="keyword">end</span>
0164 
0165 <span class="comment">% detrending</span>
0166 
0167 <span class="keyword">if</span> detrenddata
0168 
0169     disp(<span class="string">'Detrending (removing linear trend across each trial)'</span>);
0170 
0171     <span class="keyword">for</span> i=nchannels
0172         <span class="keyword">for</span> j=1:ntrials
0173             EPHYS_DATA(:,j,i)=detrend(EPHYS_DATA(:,j,i));
0174         <span class="keyword">end</span>
0175     <span class="keyword">end</span>
0176 <span class="keyword">end</span>
0177 
0178 <span class="comment">% filtering</span>
0179 
0180 <span class="keyword">if</span> filtering
0181     
0182     disp([<span class="string">'Filter order '</span> num2str(filt_order)]);
0183     disp([<span class="string">'Frequency range '</span> num2str(freq_range)]);
0184     disp([<span class="string">'Filter type '</span> filt_type]);
0185 
0186     [b,a]=butter(filt_order,[freq_range]/(SR/2),filt_type);
0187 
0188     <span class="comment">% zero-phase filter here</span>
0189 
0190     parfor i=1:nchannels
0191         EPHYS_DATA(:,:,i)=filtfilt(b,a,squeeze(EPHYS_DATA(:,:,i)));
0192     <span class="keyword">end</span>
0193 <span class="keyword">end</span>
0194 
0195 <span class="comment">% rectification</span>
0196 
0197 <span class="keyword">if</span> rectify
0198 
0199     disp(<span class="string">'Rectifying data (squaring)'</span>);
0200 
0201     <span class="keyword">for</span> i=1:nchannels
0202         EPHYS_DATA(:,:,i)=EPHYS_DATA(:,:,i).^2;
0203     <span class="keyword">end</span>
0204 
0205 <span class="keyword">end</span>
0206 
0207 <span class="comment">% finally, smoothing</span>
0208 
0209 <span class="keyword">if</span> smoothdata
0210     
0211     disp([<span class="string">'Smoothing data with Gaussian kernel, sigma='</span> num2str(sigma*1e3) <span class="string">' ms'</span>]);
0212     
0213     edges=[-3*sigma:1/SR:3*sigma];
0214     kernel=(1/(sigma*sqrt(2*pi)))*exp((-(edges-0).^2)./(2*sigma^2));
0215     kernel=kernel./sum(kernel); <span class="comment">% normalize to sum to 1</span>
0216 
0217     <span class="keyword">for</span> i=1:nchannels
0218         parfor j=1:ntrials
0219             EPHYS_DATA(:,j,i)=conv(EPHYS_DATA(:,j,i),kernel,<span class="string">'same'</span>);
0220         <span class="keyword">end</span>
0221     <span class="keyword">end</span>
0222 
0223 <span class="keyword">end</span>
0224</pre></div>
<hr><address>Generated on Thu 19-Jul-2012 21:29:37 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>