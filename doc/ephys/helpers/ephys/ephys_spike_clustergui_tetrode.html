<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ephys_spike_clustergui_tetrode</title>
  <meta name="keywords" content="ephys_spike_clustergui_tetrode">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../menu.html">Home</a> &gt;  <a href="../../menu.html">ephys</a> &gt; <a href="../menu.html">helpers</a> &gt; <a href="menu.html">ephys</a> &gt; ephys_spike_clustergui_tetrode.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../menu.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="menu.html">Index for ephys/helpers/ephys&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>ephys_spike_clustergui_tetrode
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [LABELS TRIALS ISI WINDOWS]=ephys_spike_clustergui_tetrode(SPIKEWINDOWS,SPIKETIMES,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">
 GUI for choosing a cluster based on scores calculated by
 outloop.m.  Simply run the script without any arguments
 after outloop.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="get_wavelet_coefficients.html" class="code" title="function SELCOEFFS=get_wavelet_coefficients(WAVEFORMS,NCOEFFS,varargin)">get_wavelet_coefficients</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../ephys/ephys_visual_sua.html" class="code" title="function ephys_visual_sua(EPHYS_DATA,HISTOGRAM,CHANNELS,varargin)">ephys_visual_sua</a>	ephys_visual_sua.m takes data generated by intan_cluster.m and stored in extracted_data.mat</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function change_plot(varargin)</a></li><li><a href="#_sub2" class="code">function change_cluster(varargin)</a></li><li><a href="#_sub3" class="code">function show_stats(varargin)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [LABELS TRIALS ISI WINDOWS]=ephys_spike_clustergui_tetrode(SPIKEWINDOWS,SPIKETIMES,varargin)</a>
0002 <span class="comment">%</span>
0003 <span class="comment">% GUI for choosing a cluster based on scores calculated by</span>
0004 <span class="comment">% outloop.m.  Simply run the script without any arguments</span>
0005 <span class="comment">% after outloop.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%</span>
0008 
0009 <span class="comment">% load the information collected by outloop</span>
0010 
0011 <span class="comment">% spikewindows', rows x samples, each row is a windowed spike waveform</span>
0012 
0013 <span class="comment">% some standard spike features, spike width, height</span>
0014 
0015 <span class="comment">% we need to upsample to get a true representation of the underlying waveform</span>
0016 
0017 TRIALS=[]; <span class="comment">% by default we don't need this, unless input is over multiple trials</span>
0018 sr=25e3;
0019 interpolate=1; <span class="comment">% do we want to interpolate the spikes for feature calculation?</span>
0020 interpolate_fs=50e3; <span class="comment">% interpolate</span>
0021 interpolate_method=<span class="string">'sinc'</span>; <span class="comment">% sinc or spline?</span>
0022 features={<span class="string">'P2P'</span>,<span class="string">'width'</span>,<span class="string">'energy'</span>,<span class="string">'min'</span>,<span class="string">'ISI'</span>,<span class="string">'Spiketimes'</span>,<span class="string">'PCA'</span>,<span class="string">'wavelets'</span>}; <span class="comment">% possible features include, min, max, PCA, width</span>
0023                      <span class="comment">% energy and wavelet coefficients</span>
0024 outlier_cutoff=.5;                     
0025 channel_labels=[];
0026 nparams=length(varargin);
0027 colors={<span class="string">'b'</span>,<span class="string">'r'</span>,<span class="string">'g'</span>,<span class="string">'c'</span>,<span class="string">'m'</span>,<span class="string">'y'</span>,<span class="string">'k'</span>,<span class="string">'r'</span>,<span class="string">'g'</span>,<span class="string">'b'</span>};
0028 NDIMS=[];
0029 LEGEND_LABELS={};
0030 LABELS=[];
0031 ISI={};
0032 WINDOWS={};
0033 CLUSTERS=[];
0034 wavelets=5; <span class="comment">% chooses top N non-normal wavelets according to either negentropy or KS test</span>
0035 
0036 <span class="keyword">if</span> mod(nparams,2)&gt;0
0037     error(<span class="string">'Parameters must be specified as parameter/value pairs!'</span>);
0038 <span class="keyword">end</span>
0039 
0040 <span class="keyword">for</span> i=1:2:nparams
0041     <span class="keyword">switch</span> lower(varargin{i})
0042         <span class="keyword">case</span> <span class="string">'sr'</span>
0043             sr=varargin{i+1};
0044         <span class="keyword">case</span> <span class="string">'interpolate'</span>
0045             interpolate=varargin{i+1};
0046         <span class="keyword">case</span> <span class="string">'interpolate_fs'</span>
0047             interpolate_fs=varargin{i+1};
0048         <span class="keyword">case</span> <span class="string">'features'</span>
0049             features=varargin{i+1};
0050         <span class="keyword">case</span> <span class="string">'channel_labels'</span>
0051             channel_labels=varargin{i+1};
0052         <span class="keyword">case</span> <span class="string">'wavelets'</span>
0053             wavelets=varargin{i+1};
0054     <span class="keyword">end</span>
0055 <span class="keyword">end</span>
0056 
0057 <span class="comment">% need to deal with cell input (multiple trials), convert input to big matrix</span>
0058 <span class="comment">% and spit out trial number</span>
0059 
0060 <span class="comment">% get the number of channels</span>
0061 
0062 spiketimes=[];
0063 spikeisi=[];
0064 trialnum=[];
0065 
0066 <span class="keyword">if</span> iscell(SPIKEWINDOWS)
0067 
0068     [samples,trials,channels]=size(SPIKEWINDOWS{1});
0069 
0070     <span class="keyword">for</span> j=1:channels
0071         spikewindows{j}=[];
0072     <span class="keyword">end</span>
0073     
0074     <span class="keyword">for</span> i=1:length(SPIKEWINDOWS)
0075 
0076         [samples,trials,channels]=size(SPIKEWINDOWS{i});
0077         spiketimes=[spiketimes SPIKETIMES{i}];
0078 
0079         <span class="keyword">for</span> j=1:channels
0080             spikewindows{j}=[spikewindows{j} SPIKEWINDOWS{i}(:,:,j)];
0081         <span class="keyword">end</span>
0082 
0083         isi_tmp=[];
0084         padded_spikes=[-inf SPIKETIMES{i} inf];
0085         <span class="keyword">for</span> j=2:length(padded_spikes)-1
0086             
0087             curr_spike=padded_spikes(j);
0088             next_spike=min(padded_spikes(padded_spikes&gt;padded_spikes(j)))-curr_spike;
0089             prev_spike=curr_spike-max(padded_spikes(padded_spikes&lt;padded_spikes(j)));
0090             isi_tmp(j-1)=1/(min(next_spike,prev_spike)/sr); <span class="comment">% isi is the time from the closest spike</span>
0091         
0092         <span class="keyword">end</span>
0093 
0094         spikeisi=[spikeisi;isi_tmp(:)];
0095         trialnum=[trialnum;repmat(i,trials,1)];
0096     <span class="keyword">end</span>
0097 <span class="keyword">else</span>
0098     [samples,trials,channels]=size(SPIKEWINDOWS);
0099     <span class="keyword">for</span> i=1:channels
0100         spikewindows{i}=SPIKEWINDOWS(:,:,i);
0101     <span class="keyword">end</span>
0102 
0103     spiketimes=SPIKETIMES;
0104     trialnum=ones(size(spiketimes));
0105 
0106 <span class="keyword">end</span>
0107 
0108 <span class="keyword">if</span> isempty(channel_labels)
0109     channel_labels=[1:channels];
0110 <span class="keyword">end</span>
0111 
0112 clear SPIKEWINDOWS;
0113 TRIALS=trialnum;
0114 
0115 [samples,trials]=size(spikewindows{1});
0116 
0117 expansion=interpolate_fs/sr;
0118 interpspikes=zeros(samples*expansion,trials,channels);
0119 
0120 <span class="comment">% take the time vector and expand to 2*fs (from 25k to 50k)</span>
0121 
0122 timepoints=[1:samples]';
0123 newtimepoints=linspace(1,samples,expansion*samples)';
0124 
0125 <span class="comment">%</span>
0126 
0127 <span class="keyword">switch</span> lower(interpolate_method)
0128     <span class="keyword">case</span> <span class="string">'sinc'</span>
0129 
0130         <span class="keyword">for</span> i=1:trials
0131             <span class="keyword">for</span> j=1:channels
0132                 interpspikes(:,i,j)=sinc(newtimepoints(:,ones(size(timepoints)))-<span class="keyword">...</span>
0133                     timepoints(:,ones(size(newtimepoints)))')*spikewindows{j}(:,i);
0134             <span class="keyword">end</span>
0135         <span class="keyword">end</span>
0136 
0137     <span class="keyword">case</span> <span class="string">'spline'</span>
0138         
0139         <span class="keyword">for</span> i=1:trials
0140             <span class="keyword">for</span> j=1:channels
0141                 interpspikes(:,i)=spline(timepoints,spikewindows{j}(:,i),newtimepoints);
0142             <span class="keyword">end</span>
0143         <span class="keyword">end</span>
0144 
0145     <span class="keyword">otherwise</span>
0146     
0147         error(<span class="string">'Did not understand interpolation method agrument (must be sinc or spline)'</span>);
0148 <span class="keyword">end</span>
0149     
0150 
0151 <span class="comment">% expand to include features from all channels processed</span>
0152 
0153 spikewindows=interpspikes;
0154 
0155 <span class="comment">% by convention let's keep each channel a separate column</span>
0156 
0157 features_all={<span class="string">'max'</span>,<span class="string">'min'</span>,<span class="string">'p2p'</span>,<span class="string">'width'</span>,<span class="string">'energy'</span>,<span class="string">'PC1'</span>,<span class="string">'PC2'</span>}; <span class="comment">% all features excluding IFR and spiketimes</span>
0158 
0159 <span class="keyword">for</span> i=1:wavelets
0160     features_all{end+1}=[<span class="string">'WC'</span> num2str(i)];
0161 <span class="keyword">end</span>
0162 
0163 features_status=zeros(7+wavelets,1,<span class="string">'int8'</span>);
0164 
0165 spike_data=[];
0166 <span class="keyword">for</span> i=1:channels
0167 
0168     <span class="comment">% cheap to compute standard features</span>
0169 
0170 
0171     [max_value(:,i),max_sample]=max(spikewindows(:,:,i)',[],2); <span class="comment">% will get first max if there are multiple peaks</span>
0172     [min_value(:,i),min_sample]=min(spikewindows(:,:,i)',[],2); <span class="comment">% will get first min if there are multiple peaks (maybe interpolate?)</span>
0173     peak_to_peak(:,i)=max_value(:,i)-min_value(:,i);
0174     width(:,i)=abs(min_sample-max_sample);
0175     energy(:,i)=sum(spikewindows(:,:,i)'.^2,2);
0176 
0177 
0178     <span class="keyword">if</span> any(strcmp(<span class="string">'max'</span>,lower(features)))
0179         spike_data=[spike_data max_value];
0180         features_status(1)=1;
0181     <span class="keyword">end</span>
0182 
0183     <span class="keyword">if</span> any(strcmp(<span class="string">'min'</span>,lower(features)))
0184         spike_data=[spike_data min_value];
0185         features_status(2)=1;
0186     <span class="keyword">end</span>
0187 
0188     <span class="keyword">if</span> any(strcmp(<span class="string">'p2p'</span>,lower(features)))
0189         spike_data=[spike_data peak_to_peak];
0190         features_status(3)=1;
0191     <span class="keyword">end</span>
0192 
0193     <span class="keyword">if</span> any(strcmp(<span class="string">'width'</span>,lower(features)))
0194         spike_data=[spike_data width];
0195         features_status(4)=1;
0196     <span class="keyword">end</span>
0197 
0198     <span class="keyword">if</span> any(strcmp(<span class="string">'energy'</span>,lower(features)))
0199         spike_data=[spike_data energy];
0200         features_status(5)=1;
0201     <span class="keyword">end</span>
0202 
0203     <span class="keyword">if</span> any(strcmp(<span class="string">'pca'</span>,lower(features)))
0204         [coef score variance t2]=princomp(interpspikes(:,:,i)');
0205         spike_data=[spike_data score(:,1:2)];
0206         features_status(6:7)=1;
0207     <span class="keyword">end</span>
0208 
0209     <span class="keyword">if</span> any(strcmp(<span class="string">'wavelets'</span>,lower(features)))
0210         [coeffs]=<a href="get_wavelet_coefficients.html" class="code" title="function SELCOEFFS=get_wavelet_coefficients(WAVEFORMS,NCOEFFS,varargin)">get_wavelet_coefficients</a>(interpspikes(:,:,i),wavelets);
0211         spike_data=[spike_data coeffs];
0212         features_status(8:end)=1;
0213     <span class="keyword">end</span>
0214 <span class="keyword">end</span>
0215 
0216 active_features=find(features_status);
0217 
0218 property_names={};
0219 <span class="keyword">for</span> i=1:channels
0220     <span class="keyword">for</span> j=1:length(active_features)
0221         property_names{end+1}=[ features_all{active_features(j)} <span class="string">' CH '</span> num2str(channel_labels(i)) ];
0222     <span class="keyword">end</span>
0223 <span class="keyword">end</span>
0224 
0225 <span class="keyword">if</span> any(strcmp(<span class="string">'spiketimes'</span>,lower(features)))
0226     spike_data=[spike_data spiketimes(:)];
0227     property_names{end+1}=<span class="string">'Spike times'</span>;
0228 <span class="keyword">end</span>
0229 
0230 <span class="keyword">if</span> any(strcmp(<span class="string">'isi'</span>,lower(features)))
0231     spike_data=[spike_data spikeisi(:)];
0232     property_names{end+1}=<span class="string">'Spike ISI'</span>;
0233 
0234 <span class="keyword">end</span>
0235 
0236 main_window=figure(<span class="string">'Visible'</span>,<span class="string">'off'</span>,<span class="string">'Position'</span>,[360,500,700,600],<span class="string">'Name'</span>,<span class="string">'Data Plotter'</span>,<span class="string">'NumberTitle'</span>,<span class="string">'off'</span>);
0237 plot_axis=axes(<span class="string">'Units'</span>,<span class="string">'pixels'</span>,<span class="string">'Position'</span>,[50,50,400,400]);
0238 
0239 pop_up_x= uicontrol(<span class="string">'Style'</span>,<span class="string">'popupmenu'</span>,<span class="keyword">...</span>
0240     <span class="string">'String'</span>,property_names,<span class="keyword">...</span>
0241     <span class="string">'Position'</span>,[400,90,75,25],<span class="string">'call'</span>,@<a href="#_sub1" class="code" title="subfunction change_plot(varargin)">change_plot</a>,<span class="keyword">...</span>
0242     <span class="string">'Value'</span>,1);
0243 pop_up_x_text= uicontrol(<span class="string">'Style'</span>,<span class="string">'text'</span>,<span class="keyword">...</span>
0244     <span class="string">'String'</span>,<span class="string">'X'</span>,<span class="keyword">...</span>
0245     <span class="string">'Position'</span>,[405,130,50,45]);
0246 
0247 pop_up_y= uicontrol(<span class="string">'Style'</span>,<span class="string">'popupmenu'</span>,<span class="keyword">...</span>
0248     <span class="string">'String'</span>,property_names,<span class="keyword">...</span>
0249     <span class="string">'Position'</span>,[495,90,75,25],<span class="string">'call'</span>,@<a href="#_sub1" class="code" title="subfunction change_plot(varargin)">change_plot</a>,<span class="keyword">...</span>
0250     <span class="string">'Value'</span>,2);
0251 pop_up_y_text= uicontrol(<span class="string">'Style'</span>,<span class="string">'text'</span>,<span class="keyword">...</span>
0252     <span class="string">'String'</span>,<span class="string">'Y'</span>,<span class="keyword">...</span>
0253     <span class="string">'Position'</span>,[500,130,50,45]);
0254 
0255 pop_up_z= uicontrol(<span class="string">'Style'</span>,<span class="string">'popupmenu'</span>,<span class="keyword">...</span>
0256     <span class="string">'String'</span>,property_names,<span class="keyword">...</span>
0257     <span class="string">'Position'</span>,[595,90,75,25],<span class="string">'call'</span>,@<a href="#_sub1" class="code" title="subfunction change_plot(varargin)">change_plot</a>,<span class="keyword">...</span>
0258     <span class="string">'Value'</span>,3);
0259 pop_up_z_text= uicontrol(<span class="string">'Style'</span>,<span class="string">'text'</span>,<span class="keyword">...</span>
0260     <span class="string">'String'</span>,<span class="string">'Z'</span>,<span class="keyword">...</span>
0261     <span class="string">'Position'</span>,[600,130,50,45]);
0262 
0263 pop_up_clusters= uicontrol(<span class="string">'Style'</span>,<span class="string">'popupmenu'</span>,<span class="keyword">...</span>
0264     <span class="string">'String'</span>,{<span class="string">'auto'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>},<span class="keyword">...</span>
0265     <span class="string">'Position'</span>,[475,210,75,25]);
0266 pop_up_clusters_text= uicontrol(<span class="string">'Style'</span>,<span class="string">'text'</span>,<span class="keyword">...</span>
0267     <span class="string">'String'</span>,<span class="string">'Number of Clusters'</span>,<span class="keyword">...</span>
0268     <span class="string">'Position'</span>,[500,250,100,45]);
0269 
0270 push_replot_save= uicontrol(<span class="string">'Style'</span>,<span class="string">'pushbutton'</span>,<span class="keyword">...</span>
0271     <span class="string">'String'</span>,<span class="string">'Show cluster stats'</span>,<span class="keyword">...</span>
0272     <span class="string">'Position'</span>,[500,40,100,25],<span class="string">'call'</span>,@<a href="#_sub3" class="code" title="subfunction show_stats(varargin)">show_stats</a>);
0273 
0274 push_draw_mode= uicontrol(<span class="string">'Style'</span>,<span class="string">'pushbutton'</span>,<span class="keyword">...</span>
0275     <span class="string">'String'</span>,<span class="string">'Draw mode (x and y only)'</span>,<span class="keyword">...</span>
0276     <span class="string">'Position'</span>,[500,450,100,35],<span class="string">'value'</span>,0,<span class="keyword">...</span>
0277     <span class="string">'Call'</span>,@<a href="#_sub2" class="code" title="subfunction change_cluster(varargin)">change_cluster</a>);
0278 
0279 push_recluster= uicontrol(<span class="string">'Style'</span>,<span class="string">'pushbutton'</span>,<span class="keyword">...</span>
0280     <span class="string">'String'</span>,<span class="string">'Recluster'</span>,<span class="keyword">...</span>
0281     <span class="string">'Position'</span>,[500,550,100,35],<span class="string">'value'</span>,0,<span class="keyword">...</span>
0282     <span class="string">'Call'</span>,@<a href="#_sub2" class="code" title="subfunction change_cluster(varargin)">change_cluster</a>);
0283 
0284 rows=ceil(length(property_names)/5);
0285 
0286 i=1;
0287 <span class="keyword">while</span> i&lt;=length(property_names)
0288     row=ceil(i/5);
0289     column=mod(i,5);
0290     <span class="keyword">if</span> column==0, column=5; <span class="keyword">end</span>
0291     cluster_data_check{i}=uicontrol(<span class="string">'Style'</span>,<span class="string">'checkbox'</span>,<span class="keyword">...</span>
0292         <span class="string">'String'</span>,property_names{i},<span class="keyword">...</span>
0293         <span class="string">'Value'</span>,i==1,<span class="string">'Position'</span>,[50+column*60,600-row*35,70,25]);
0294     set(cluster_data_check{i},<span class="string">'Units'</span>,<span class="string">'Normalized'</span>)
0295     i=i+1;
0296 <span class="keyword">end</span>
0297 
0298 <span class="comment">% now align everything and send the main_window handle to the output</span>
0299 <span class="comment">% so we can use the gui with uiwait (requires the handle as a return value)</span>
0300 
0301 align([pop_up_clusters,pop_up_clusters_text,push_replot_save],<span class="string">'Center'</span>,<span class="string">'None'</span>);
0302 align([pop_up_x,pop_up_x_text],<span class="string">'Center'</span>,<span class="string">'None'</span>);
0303 align([pop_up_y,pop_up_y_text],<span class="string">'Center'</span>,<span class="string">'None'</span>);
0304 align([pop_up_z,pop_up_z_text],<span class="string">'Center'</span>,<span class="string">'None'</span>);
0305 
0306 <a href="#_sub2" class="code" title="subfunction change_cluster(varargin)">change_cluster</a>();
0307 <a href="#_sub1" class="code" title="subfunction change_plot(varargin)">change_plot</a>();
0308 
0309 <span class="comment">% run change_plot, which updates the plot according to the defaults</span>
0310 
0311 set([main_window,plot_axis,pop_up_x,pop_up_x_text,pop_up_y,pop_up_y_text,pop_up_z,<span class="keyword">...</span>
0312     pop_up_z_text,pop_up_clusters,pop_up_clusters_text,<span class="keyword">...</span>
0313     push_replot_save,push_draw_mode,push_recluster],<span class="string">'Units'</span>,<span class="string">'Normalized'</span>);
0314 movegui(main_window,<span class="string">'center'</span>)
0315 
0316 set(main_window,<span class="string">'Visible'</span>,<span class="string">'On'</span>);
0317 
0318 
0319 
0320 uiwait(main_window);
0321 
0322 <span class="comment">%% Callbacks</span>
0323 
0324 <span class="comment">% this callback changes the plot and returns the sum of the distances</span>
0325 <span class="comment">% from the centroid for each point in a cluster</span>
0326 
0327 <span class="comment">% change the plot if we change any of our dimensions, DO NOT RECLUSTER!</span>
0328 
0329 <a name="_sub1" href="#_subfunctions" class="code">function change_plot(varargin)</a>
0330 
0331 <span class="comment">% get the number of dimensions for the plot (number of principal components)</span>
0332 
0333 cla;
0334 
0335 viewdim(1)=get(pop_up_x,<span class="string">'value'</span>);
0336 viewdim(2)=get(pop_up_y,<span class="string">'value'</span>);
0337 viewdim(3)=get(pop_up_z,<span class="string">'value'</span>);
0338 
0339 view_data=spike_data(:,viewdim);
0340 
0341 <span class="keyword">if</span> NDIMS==2
0342     <span class="keyword">for</span> i=1:CLUSTERS
0343         points=find(LABELS==i);
0344         h(:,i)=plot(view_data(points,1),view_data(points,2),<span class="keyword">...</span>
0345             <span class="string">'o'</span>,<span class="string">'markerfacecolor'</span>,colors{i},<span class="string">'markeredgecolor'</span>,<span class="string">'none'</span>);hold on
0346     <span class="keyword">end</span>
0347 
0348 <span class="keyword">else</span>
0349     <span class="keyword">for</span> i=1:CLUSTERS
0350         points=find(LABELS==i);
0351         h(:,i)=plot3(view_data(points,1),view_data(points,2),view_data(points,3),<span class="keyword">...</span>
0352             <span class="string">'o'</span>,<span class="string">'markerfacecolor'</span>,colors{i},<span class="string">'markeredgecolor'</span>,<span class="string">'none'</span>);hold on
0353 
0354     <span class="keyword">end</span>
0355 <span class="keyword">end</span>
0356 
0357 grid on
0358 view(NDIMS)
0359 
0360 xlabel(property_names{viewdim(1)});
0361 ylabel(property_names{viewdim(2)});
0362 zlabel(property_names{viewdim(3)});
0363 
0364 L=legend(h,LEGEND_LABELS,<span class="string">'Location'</span>,<span class="string">'NorthEastOutside'</span>);legend boxoff
0365 set(L,<span class="string">'FontSize'</span>,20,<span class="string">'FontName'</span>,<span class="string">'Helvetica'</span>)
0366 
0367 <span class="keyword">end</span>
0368 
0369 <a name="_sub2" href="#_subfunctions" class="code">function change_cluster(varargin)</a>
0370 
0371 <span class="comment">% label everything</span>
0372 <span class="comment">% use the dimensions ticked in the top box for clustering</span>
0373 
0374 dim=[];
0375 <span class="keyword">for</span> i=1:length(cluster_data_check)
0376 
0377     value=get(cluster_data_check{i},<span class="string">'Value'</span>);
0378 
0379     <span class="keyword">if</span> value
0380         dim=[dim i];
0381     <span class="keyword">end</span>
0382 
0383 <span class="keyword">end</span>
0384 
0385 draw_mode=get(push_draw_mode,<span class="string">'value'</span>);
0386 
0387 clusterchoices=get(pop_up_clusters,<span class="string">'string'</span>);
0388 clusterselection=get(pop_up_clusters,<span class="string">'value'</span>);
0389 
0390 clusterchoice=clusterchoices{clusterselection};
0391 
0392 <span class="comment">% perform the kmeans analysis and return the labels, centroid coordinates,</span>
0393 <span class="comment">% sum of all points in each cluster from their respective centroid and</span>
0394 <span class="comment">% the distance of all points from all centroids</span>
0395 
0396 <span class="comment">% start with one cluster, go up to 10 and check the within distance for all clusters</span>
0397 
0398 cluster_data=spike_data(:,dim);
0399 [datapoints,features]=size(spike_data);
0400 
0401 <span class="keyword">if</span> ~draw_mode
0402     options=statset(<span class="string">'Display'</span>,<span class="string">'off'</span>);
0403 
0404     clustnum=2:5;
0405     <span class="keyword">if</span> datapoints&lt;=features
0406         disp(<span class="string">'Too few spikes to fit'</span>);
0407         <span class="keyword">return</span>;
0408     <span class="keyword">end</span>
0409 
0410     <span class="comment">% gaussian mixture seems to work better than fcm</span>
0411 
0412     <span class="keyword">if</span> strcmp(lower(clusterchoice),<span class="string">'auto'</span>)
0413 
0414         parfor i=1:length(clustnum)
0415 
0416             testobj=gmdistribution.fit(cluster_data,clustnum(i),<span class="string">'Regularize'</span>,1,<span class="string">'Options'</span>,options);
0417             
0418             <span class="comment">%[center,u,obj_fcn]=fcm(cluster_data,clustnum(i),[NaN NaN NaN 0]);</span>
0419             
0420             <span class="comment">% compute the partition coefficient, simply all membership indices squared and summed</span>
0421 
0422             <span class="comment">%partition_coef(i)=sum(sum(u.^2))/datapoints;</span>
0423 
0424             AIC(i)=testobj.AIC;
0425             logl(i)=testobj.NlogL;
0426             disp([ num2str(clustnum(i)) <span class="string">' clusters'</span>]);
0427 
0428             <span class="comment">%disp(['Partition coefficient ' num2str(partition_coef(i))]);</span>
0429             disp([ <span class="string">'AIC '</span> num2str(testobj.AIC)]) <span class="comment">% Akaike information criterion</span>
0430             <span class="comment">%disp([ 'BIC ' num2str(testobj.BIC)]) % Bayes information criterion</span>
0431 
0432         <span class="keyword">end</span>
0433 
0434         [val,loc]=max(diff(diff(logl))); <span class="comment">% maximum derivative in log-likelihood over k</span>
0435         nclust=clustnum(loc);
0436         CLUSTERS=nclust;
0437 
0438     <span class="keyword">else</span>
0439         CLUSTERS=str2num(clusterchoice);
0440 
0441     <span class="keyword">end</span>
0442 
0443     disp([<span class="string">'Will use '</span> num2str(CLUSTERS) <span class="string">' clusters'</span>]);
0444 
0445     testobj=gmdistribution.fit(cluster_data,CLUSTERS,<span class="string">'Regularize'</span>,1,<span class="string">'Options'</span>,options);
0446     [idx,nlogl,P]=cluster(testobj,cluster_data);
0447     <span class="comment">%[center,u,obj_fcn]=fcm(cluster_data,CLUSTERS,[NaN NaN NaN 0]);</span>
0448 
0449     counter=1;
0450 
0451     <span class="keyword">for</span> i=1:datapoints
0452 
0453         <span class="comment">%[membership(i),idx(i)]=max(u(:,i)); % take posterior probability of the chosen cluster</span>
0454                             <span class="comment">% given observation i as the measure of &quot;membership&quot;</span>
0455         membership(i)=P(i,idx(i));
0456 
0457         <span class="keyword">if</span> membership(i)&lt;outlier_cutoff
0458             idx(i)=CLUSTERS+1; <span class="comment">% assign new &quot;junk cluster&quot;</span>
0459             counter=counter+1;
0460         <span class="keyword">end</span>
0461     <span class="keyword">end</span>
0462 
0463     disp([ num2str(counter) <span class="string">' outliers'</span>]);
0464 
0465     clusterlabels=unique(idx);
0466     CLUSTERS=length(clusterlabels);
0467 
0468     <span class="keyword">for</span> i=1:length(clusterlabels)
0469         idx(idx==clusterlabels(i))=i;    
0470     <span class="keyword">end</span>
0471 
0472     <span class="comment">% return labels, and windows and ISI sorted by cluster IDX</span>
0473 
0474     LABELS=idx;
0475     NDIMS=3;
0476 
0477     <span class="comment">% clear the plot axis</span>
0478 <span class="keyword">else</span>
0479 
0480     viewdim(1)=get(pop_up_x,<span class="string">'value'</span>);
0481     viewdim(2)=get(pop_up_y,<span class="string">'value'</span>);
0482 
0483     view_data=spike_data(:,viewdim);
0484 
0485     cla;
0486     LABELS=ones(datapoints,1);
0487     response=[];
0488     counter=2;
0489 
0490     plot(view_data(:,1),view_data(:,2),<span class="string">'o'</span>,<span class="string">'markerfacecolor'</span>,colors{1});view(2);
0491     hold on
0492     disp(<span class="string">'Select the corners of the enclosing polygon then press RETURN to continue...'</span>);
0493     hold off;
0494 
0495     <span class="keyword">while</span> isempty(response)
0496 
0497         [xv,yv]=ginput;
0498         k=convhull(xv,yv);    
0499         hold on;
0500         plot(xv(k),yv(k),<span class="string">'b-'</span>,<span class="string">'linewidth'</span>,1.25);
0501         choice=inpolygon(view_data(:,1),view_data(:,2),xv(k),yv(k));
0502         LABELS(choice==1)=counter;
0503         response=input(<span class="string">'(D)one clustering or (c)ontinue?  '</span>,<span class="string">'s'</span>);
0504 
0505         <span class="keyword">switch</span> lower(response)
0506             <span class="keyword">case</span> <span class="string">'d'</span>
0507                 <span class="keyword">break</span>;
0508             <span class="keyword">case</span> <span class="string">'c'</span>
0509                 response=[];
0510             <span class="keyword">otherwise</span>
0511                 response=[];
0512         <span class="keyword">end</span>
0513 
0514         counter=counter+1;
0515 
0516     <span class="keyword">end</span>
0517     
0518     CLUSTERS=counter;
0519     NDIMS=3;
0520 
0521 <span class="keyword">end</span>
0522 
0523 <span class="comment">% plot in either 2 or 3 dims</span>
0524 <span class="comment">% turns out plot is MUCH faster than scatter, changed accordingly...</span>
0525 
0526 LEGEND_LABELS={};
0527 <span class="keyword">for</span> i=1:CLUSTERS
0528     LEGEND_LABELS{i}=num2str(i);
0529 <span class="keyword">end</span>
0530 
0531 <span class="comment">% compute any other stats we want, ISI, etc...</span>
0532 
0533 [uniq_trial trial_boundary trial_group]=unique(trialnum);
0534 trial_boundary=[1;trial_boundary];
0535 
0536 <span class="keyword">for</span> i=1:CLUSTERS
0537 
0538     spikewintmp=spikewindows(:,LABELS==i,1);
0539 
0540     <span class="comment">% need to collect isi within trial, don't count the first spike!</span>
0541     
0542     spikeisitmp=[];
0543 
0544     <span class="keyword">for</span> j=1:length(uniq_trial)
0545         
0546         <span class="comment">% all spike times in this trial</span>
0547         
0548         currtrial=spiketimes(trial_boundary(j):trial_boundary(j+1));
0549 
0550         <span class="comment">% now all spike ids from this trial</span>
0551 
0552         currlabels=LABELS(trialnum==uniq_trial(j));
0553 
0554         <span class="comment">% spike times for this cluster</span>
0555 
0556         currtrial=currtrial(currlabels==i);
0557 
0558         currisi=(diff(currtrial)); <span class="comment">% isi in msec</span>
0559         spikeisitmp=[spikeisitmp;currisi(:)];
0560     <span class="keyword">end</span>
0561 
0562     ISI{i}=spikeisitmp;
0563     WINDOWS{i}=spikewintmp;
0564 
0565 <span class="keyword">end</span>
0566 
0567 <a href="#_sub1" class="code" title="subfunction change_plot(varargin)">change_plot</a>();
0568 
0569 <span class="keyword">end</span>    
0570 
0571 <a name="_sub3" href="#_subfunctions" class="code">function show_stats(varargin)</a>
0572 
0573 <span class="comment">% get the labels from the main_window</span>
0574 
0575 statfig=figure(<span class="string">'Visible'</span>,<span class="string">'off'</span>);
0576 
0577 counter=1;
0578 binedges=[0:.1:10];
0579 
0580 ymin=inf;
0581 ymax=-inf;
0582 
0583 <span class="keyword">for</span> i=1:CLUSTERS
0584 
0585     ax(i)=subplot(CLUSTERS,2,counter);
0586     [samples,trials]=size(WINDOWS{i});
0587 
0588     <span class="keyword">if</span> ~interpolate
0589         plot(([1:samples]./sr)*1e3,WINDOWS{i});
0590     <span class="keyword">else</span>        
0591         plot(([1:samples]./interpolate_fs)*1e3,WINDOWS{i});
0592     <span class="keyword">end</span>
0593 
0594     ylabel(<span class="string">'microvolts'</span>);
0595     xlabel(<span class="string">'msec'</span>);
0596     axis tight
0597     ylimits=ylim();
0598     
0599     <span class="keyword">if</span> ylimits(1)&lt;ymin
0600         ymin=ylimits(1);
0601     <span class="keyword">end</span>
0602     
0603     <span class="keyword">if</span> ylimits(2)&gt;ymax
0604         ymax=ylimits(2);
0605     <span class="keyword">end</span>
0606 
0607     <span class="comment">%[f,xi]=ksdensity(spikeisi);</span>
0608     
0609     xlimits=xlim();
0610     xlim([0 xlimits(2)]);
0611 
0612     counter=counter+1;
0613     ax2=subplot(CLUSTERS,2,counter);
0614     density=histc((ISI{i}/sr)*1e3,binedges);
0615     bar(binedges,density,<span class="string">'histc'</span>);
0616     xlabel(<span class="string">'ISI (msec)'</span>);
0617     ylabel(<span class="string">'N'</span>);
0618     xlim([binedges(1) binedges(end)]);
0619 
0620     counter=counter+1;
0621 <span class="keyword">end</span>
0622 
0623 linkaxes(ax,<span class="string">'xy'</span>);
0624 set(ax(1),<span class="string">'ylim'</span>,[ymin ymax]);
0625 linkaxes(ax2,<span class="string">'xy'</span>);
0626 
0627 set(statfig,<span class="string">'visible'</span>,<span class="string">'on'</span>);
0628 
0629 <span class="keyword">end</span>
0630 
0631 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 19-Jul-2012 21:29:37 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>