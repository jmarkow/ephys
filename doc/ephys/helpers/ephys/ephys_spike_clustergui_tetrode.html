<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ephys_spike_clustergui_tetrode</title>
  <meta name="keywords" content="ephys_spike_clustergui_tetrode">
  <meta name="description" content="GUI for spike cluster cutting">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../menu.html">Home</a> &gt;  <a href="../../menu.html">ephys</a> &gt; <a href="../menu.html">helpers</a> &gt; <a href="menu.html">ephys</a> &gt; ephys_spike_clustergui_tetrode.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../menu.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="menu.html">Index for ephys/helpers/ephys&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>ephys_spike_clustergui_tetrode
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>GUI for spike cluster cutting</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [LABELS TRIALS ISI WINDOWS]=ephys_spike_clustergui_tetrode(SPIKEWINDOWS,SPIKETIMES,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">GUI for spike cluster cutting</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="get_wavelet_coefficients.html" class="code" title="function SELCOEFFS=get_wavelet_coefficients(WAVEFORMS,NCOEFFS,varargin)">get_wavelet_coefficients</a>	gets wavelet coefficients and sorts according to ks stat, negentropy, or coefficient of bimodality</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../ephys/ephys_visual_sua.html" class="code" title="function ephys_visual_sua(EPHYS_DATA,HISTOGRAM,CHANNELS,varargin)">ephys_visual_sua</a>	generates song-aligned single-unit rasters</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function change_plot(varargin)</a></li><li><a href="#_sub2" class="code">function change_cluster(varargin)</a></li><li><a href="#_sub3" class="code">function show_stats(varargin)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [LABELS TRIALS ISI WINDOWS]=ephys_spike_clustergui_tetrode(SPIKEWINDOWS,SPIKETIMES,varargin)</a>
0002 <span class="comment">%GUI for spike cluster cutting</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%</span>
0005 
0006 <span class="comment">% spikewindows', rows x samples, each row is a windowed spike waveform</span>
0007 
0008 TRIALS=[]; <span class="comment">% by default we don't need this, unless input is over multiple trials</span>
0009 sr=25e3;
0010 interpolate=1; <span class="comment">% do we want to interpolate the spikes for feature calculation?</span>
0011 interpolate_fs=50e3; <span class="comment">% interpolate</span>
0012 interpolate_method=<span class="string">'sinc'</span>; <span class="comment">% sinc or spline?</span>
0013 features={<span class="string">'P2P'</span>,<span class="string">'width'</span>,<span class="string">'energy'</span>,<span class="string">'min'</span>,<span class="string">'ISI'</span>,<span class="string">'Spiketimes'</span>,<span class="string">'PCA'</span>,<span class="string">'wavelets'</span>}; <span class="comment">% possible features include, min, max, PCA, width</span>
0014                      <span class="comment">% energy and wavelet coefficients</span>
0015 outlier_cutoff=.5;                     
0016 channel_labels=[];
0017 nparams=length(varargin);
0018 colors={<span class="string">'b'</span>,<span class="string">'r'</span>,<span class="string">'g'</span>,<span class="string">'c'</span>,<span class="string">'m'</span>,<span class="string">'y'</span>,<span class="string">'k'</span>,<span class="string">'r'</span>,<span class="string">'g'</span>,<span class="string">'b'</span>};
0019 NDIMS=[];
0020 LEGEND_LABELS={};
0021 LABELS=[];
0022 ISI={};
0023 WINDOWS={};
0024 CLUSTERS=[];
0025 wavelets=10; <span class="comment">% chooses top N non-normal wavelets according to either negentropy or KS test</span>
0026 <span class="comment">%</span>
0027 <span class="keyword">if</span> mod(nparams,2)&gt;0
0028     error(<span class="string">'Parameters must be specified as parameter/value pairs!'</span>);
0029 <span class="keyword">end</span>
0030 
0031 <span class="keyword">for</span> i=1:2:nparams
0032     <span class="keyword">switch</span> lower(varargin{i})
0033         <span class="keyword">case</span> <span class="string">'sr'</span>
0034             sr=varargin{i+1};
0035         <span class="keyword">case</span> <span class="string">'interpolate'</span>
0036             interpolate=varargin{i+1};
0037         <span class="keyword">case</span> <span class="string">'interpolate_fs'</span>
0038             interpolate_fs=varargin{i+1};
0039         <span class="keyword">case</span> <span class="string">'features'</span>
0040             features=varargin{i+1};
0041         <span class="keyword">case</span> <span class="string">'channel_labels'</span>
0042             channel_labels=varargin{i+1};
0043         <span class="keyword">case</span> <span class="string">'wavelets'</span>
0044             wavelets=varargin{i+1};
0045     <span class="keyword">end</span>
0046 <span class="keyword">end</span>
0047 
0048 <span class="comment">% need to deal with cell input (multiple trials), convert input to big matrix</span>
0049 <span class="comment">% and spit out trial number</span>
0050 
0051 <span class="comment">% get the number of channels</span>
0052 
0053 spiketimes=[];
0054 spikeisi=[];
0055 trialnum=[];
0056 
0057 <span class="keyword">if</span> iscell(SPIKEWINDOWS)
0058 
0059     [samples,trials,channels]=size(SPIKEWINDOWS{1});
0060 
0061     <span class="keyword">for</span> j=1:channels
0062         spikewindows{j}=[];
0063     <span class="keyword">end</span>
0064     
0065     <span class="keyword">for</span> i=1:length(SPIKEWINDOWS)
0066 
0067         [samples,trials,channels]=size(SPIKEWINDOWS{i});
0068         spiketimes=[spiketimes SPIKETIMES{i}];
0069 
0070         <span class="keyword">for</span> j=1:channels
0071             spikewindows{j}=[spikewindows{j} SPIKEWINDOWS{i}(:,:,j)];
0072         <span class="keyword">end</span>
0073 
0074         isi_tmp=[];
0075         padded_spikes=[-inf SPIKETIMES{i} inf];
0076         <span class="keyword">for</span> j=2:length(padded_spikes)-1
0077             
0078             curr_spike=padded_spikes(j);
0079             next_spike=min(padded_spikes(padded_spikes&gt;padded_spikes(j)))-curr_spike;
0080             prev_spike=curr_spike-max(padded_spikes(padded_spikes&lt;padded_spikes(j)));
0081             isi_tmp(j-1)=1/(min(next_spike,prev_spike)/sr); <span class="comment">% isi is the time from the closest spike</span>
0082         
0083         <span class="keyword">end</span>
0084 
0085         spikeisi=[spikeisi;isi_tmp(:)];
0086         trialnum=[trialnum;repmat(i,trials,1)];
0087     <span class="keyword">end</span>
0088 <span class="keyword">else</span>
0089     [samples,trials,channels]=size(SPIKEWINDOWS);
0090     <span class="keyword">for</span> i=1:channels
0091         spikewindows{i}=SPIKEWINDOWS(:,:,i);
0092     <span class="keyword">end</span>
0093 
0094     spiketimes=SPIKETIMES;
0095     trialnum=ones(size(spiketimes));
0096 
0097 <span class="keyword">end</span>
0098 
0099 <span class="keyword">if</span> isempty(channel_labels)
0100     channel_labels=[1:channels];
0101 <span class="keyword">end</span>
0102 
0103 clear SPIKEWINDOWS;
0104 TRIALS=trialnum;
0105 
0106 [samples,trials]=size(spikewindows{1});
0107 
0108 expansion=interpolate_fs/sr;
0109 interpspikes=zeros(samples*expansion,trials,channels);
0110 
0111 <span class="comment">% take the time vector and expand to 2*fs (from 25k to 50k)</span>
0112 
0113 timepoints=[1:samples]';
0114 newtimepoints=linspace(1,samples,expansion*samples)';
0115 
0116 <span class="comment">%</span>
0117 
0118 <span class="keyword">switch</span> lower(interpolate_method)
0119     <span class="keyword">case</span> <span class="string">'sinc'</span>
0120 
0121         <span class="keyword">for</span> i=1:trials
0122             <span class="keyword">for</span> j=1:channels
0123                 interpspikes(:,i,j)=sinc(newtimepoints(:,ones(size(timepoints)))-<span class="keyword">...</span>
0124                     timepoints(:,ones(size(newtimepoints)))')*spikewindows{j}(:,i);
0125             <span class="keyword">end</span>
0126         <span class="keyword">end</span>
0127 
0128     <span class="keyword">case</span> <span class="string">'spline'</span>
0129         
0130         <span class="keyword">for</span> i=1:trials
0131             <span class="keyword">for</span> j=1:channels
0132                 interpspikes(:,i)=spline(timepoints,spikewindows{j}(:,i),newtimepoints);
0133             <span class="keyword">end</span>
0134         <span class="keyword">end</span>
0135 
0136     <span class="keyword">otherwise</span>
0137     
0138         error(<span class="string">'Did not understand interpolation method agrument (must be sinc or spline)'</span>);
0139 <span class="keyword">end</span>
0140     
0141 
0142 <span class="comment">% expand to include features from all channels processed</span>
0143 
0144 spikewindows=interpspikes;
0145 
0146 <span class="comment">% by convention let's keep each channel a separate column</span>
0147 
0148 features_all={<span class="string">'max'</span>,<span class="string">'min'</span>,<span class="string">'p2p'</span>,<span class="string">'width'</span>,<span class="string">'energy'</span>,<span class="string">'PC1'</span>,<span class="string">'PC2'</span>}; <span class="comment">% all features excluding IFR and spiketimes</span>
0149 
0150 <span class="keyword">for</span> i=1:wavelets
0151     features_all{7+i}=[<span class="string">'WC'</span> num2str(i)];
0152 <span class="keyword">end</span>
0153 
0154 features_status=zeros(7+wavelets,1,<span class="string">'int8'</span>);
0155 
0156 spike_data=[];
0157 <span class="keyword">for</span> i=1:channels
0158 
0159     <span class="comment">% cheap to compute standard features</span>
0160 
0161 
0162     [max_value(:,i),max_sample]=max(spikewindows(:,:,i)',[],2); <span class="comment">% will get first max if there are multiple peaks</span>
0163     [min_value(:,i),min_sample]=min(spikewindows(:,:,i)',[],2); <span class="comment">% will get first min if there are multiple peaks (maybe interpolate?)</span>
0164     peak_to_peak(:,i)=max_value(:,i)-min_value(:,i);
0165     width(:,i)=abs(min_sample-max_sample);
0166     energy(:,i)=sum(spikewindows(:,:,i)'.^2,2);
0167 
0168 
0169     <span class="keyword">if</span> any(strcmp(<span class="string">'max'</span>,lower(features)))
0170         spike_data=[spike_data max_value];
0171         features_status(1)=1;
0172     <span class="keyword">end</span>
0173 
0174     <span class="keyword">if</span> any(strcmp(<span class="string">'min'</span>,lower(features)))
0175         spike_data=[spike_data min_value];
0176         features_status(2)=1;
0177     <span class="keyword">end</span>
0178 
0179     <span class="keyword">if</span> any(strcmp(<span class="string">'p2p'</span>,lower(features)))
0180         spike_data=[spike_data peak_to_peak];
0181         features_status(3)=1;
0182     <span class="keyword">end</span>
0183 
0184     <span class="keyword">if</span> any(strcmp(<span class="string">'width'</span>,lower(features)))
0185         spike_data=[spike_data width];
0186         features_status(4)=1;
0187     <span class="keyword">end</span>
0188 
0189     <span class="keyword">if</span> any(strcmp(<span class="string">'energy'</span>,lower(features)))
0190         spike_data=[spike_data energy];
0191         features_status(5)=1;
0192     <span class="keyword">end</span>
0193 
0194     <span class="keyword">if</span> any(strcmp(<span class="string">'pca'</span>,lower(features)))
0195         [coef score variance t2]=princomp(interpspikes(:,:,i)');
0196         spike_data=[spike_data score(:,1:2)];
0197         features_status(6:7)=1;
0198     <span class="keyword">end</span>
0199 
0200     <span class="keyword">if</span> any(strcmp(<span class="string">'wavelets'</span>,lower(features)))
0201         [coeffs]=<a href="get_wavelet_coefficients.html" class="code" title="function SELCOEFFS=get_wavelet_coefficients(WAVEFORMS,NCOEFFS,varargin)">get_wavelet_coefficients</a>(interpspikes(:,:,i),wavelets,<span class="string">'method'</span>,<span class="string">'bimodal'</span>);
0202         [m,ncoeffs]=size(coeffs);
0203         spike_data=[spike_data coeffs];
0204         features_status(8:end)=1;
0205     <span class="keyword">end</span>
0206 <span class="keyword">end</span>
0207 
0208 features_status=features_status(1:7+ncoeffs);
0209 features_all=features_all(1:7+ncoeffs);
0210 
0211 active_features=find(features_status);
0212 
0213 property_names={};
0214 <span class="keyword">for</span> i=1:channels
0215     <span class="keyword">for</span> j=1:length(active_features)
0216         property_names{end+1}=[ features_all{active_features(j)} <span class="string">' CH '</span> num2str(channel_labels(i)) ];
0217     <span class="keyword">end</span>
0218 <span class="keyword">end</span>
0219 
0220 <span class="keyword">if</span> any(strcmp(<span class="string">'spiketimes'</span>,lower(features)))
0221     spike_data=[spike_data spiketimes(:)];
0222     property_names{end+1}=<span class="string">'Spike times'</span>;
0223 <span class="keyword">end</span>
0224 
0225 <span class="keyword">if</span> any(strcmp(<span class="string">'isi'</span>,lower(features)))
0226     spike_data=[spike_data spikeisi(:)];
0227     property_names{end+1}=<span class="string">'Spike ISI'</span>;
0228 
0229 <span class="keyword">end</span>
0230 
0231 main_window=figure(<span class="string">'Visible'</span>,<span class="string">'off'</span>,<span class="string">'Position'</span>,[360,500,700,600],<span class="string">'Name'</span>,<span class="string">'Data Plotter'</span>,<span class="string">'NumberTitle'</span>,<span class="string">'off'</span>);
0232 plot_axis=axes(<span class="string">'Units'</span>,<span class="string">'pixels'</span>,<span class="string">'Position'</span>,[50,50,400,400]);
0233 
0234 pop_up_x= uicontrol(<span class="string">'Style'</span>,<span class="string">'popupmenu'</span>,<span class="keyword">...</span>
0235     <span class="string">'String'</span>,property_names,<span class="keyword">...</span>
0236     <span class="string">'Position'</span>,[400,90,75,25],<span class="string">'call'</span>,@<a href="#_sub1" class="code" title="subfunction change_plot(varargin)">change_plot</a>,<span class="keyword">...</span>
0237     <span class="string">'Value'</span>,1);
0238 pop_up_x_text= uicontrol(<span class="string">'Style'</span>,<span class="string">'text'</span>,<span class="keyword">...</span>
0239     <span class="string">'String'</span>,<span class="string">'X'</span>,<span class="keyword">...</span>
0240     <span class="string">'Position'</span>,[405,130,50,45]);
0241 
0242 pop_up_y= uicontrol(<span class="string">'Style'</span>,<span class="string">'popupmenu'</span>,<span class="keyword">...</span>
0243     <span class="string">'String'</span>,property_names,<span class="keyword">...</span>
0244     <span class="string">'Position'</span>,[495,90,75,25],<span class="string">'call'</span>,@<a href="#_sub1" class="code" title="subfunction change_plot(varargin)">change_plot</a>,<span class="keyword">...</span>
0245     <span class="string">'Value'</span>,2);
0246 pop_up_y_text= uicontrol(<span class="string">'Style'</span>,<span class="string">'text'</span>,<span class="keyword">...</span>
0247     <span class="string">'String'</span>,<span class="string">'Y'</span>,<span class="keyword">...</span>
0248     <span class="string">'Position'</span>,[500,130,50,45]);
0249 
0250 pop_up_z= uicontrol(<span class="string">'Style'</span>,<span class="string">'popupmenu'</span>,<span class="keyword">...</span>
0251     <span class="string">'String'</span>,property_names,<span class="keyword">...</span>
0252     <span class="string">'Position'</span>,[595,90,75,25],<span class="string">'call'</span>,@<a href="#_sub1" class="code" title="subfunction change_plot(varargin)">change_plot</a>,<span class="keyword">...</span>
0253     <span class="string">'Value'</span>,3);
0254 pop_up_z_text= uicontrol(<span class="string">'Style'</span>,<span class="string">'text'</span>,<span class="keyword">...</span>
0255     <span class="string">'String'</span>,<span class="string">'Z'</span>,<span class="keyword">...</span>
0256     <span class="string">'Position'</span>,[600,130,50,45]);
0257 
0258 pop_up_clusters= uicontrol(<span class="string">'Style'</span>,<span class="string">'popupmenu'</span>,<span class="keyword">...</span>
0259     <span class="string">'String'</span>,{<span class="string">'auto'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>},<span class="keyword">...</span>
0260     <span class="string">'Position'</span>,[475,210,75,25]);
0261 pop_up_clusters_text= uicontrol(<span class="string">'Style'</span>,<span class="string">'text'</span>,<span class="keyword">...</span>
0262     <span class="string">'String'</span>,<span class="string">'Number of Clusters'</span>,<span class="keyword">...</span>
0263     <span class="string">'Position'</span>,[500,250,100,45]);
0264 
0265 push_replot_save= uicontrol(<span class="string">'Style'</span>,<span class="string">'pushbutton'</span>,<span class="keyword">...</span>
0266     <span class="string">'String'</span>,<span class="string">'Show cluster stats'</span>,<span class="keyword">...</span>
0267     <span class="string">'Position'</span>,[500,40,100,25],<span class="string">'call'</span>,@<a href="#_sub3" class="code" title="subfunction show_stats(varargin)">show_stats</a>);
0268 
0269 push_draw_mode= uicontrol(<span class="string">'Style'</span>,<span class="string">'pushbutton'</span>,<span class="keyword">...</span>
0270     <span class="string">'String'</span>,<span class="string">'Draw mode (x and y only)'</span>,<span class="keyword">...</span>
0271     <span class="string">'Position'</span>,[500,450,100,35],<span class="string">'value'</span>,0,<span class="keyword">...</span>
0272     <span class="string">'Call'</span>,@<a href="#_sub2" class="code" title="subfunction change_cluster(varargin)">change_cluster</a>);
0273 
0274 push_recluster= uicontrol(<span class="string">'Style'</span>,<span class="string">'pushbutton'</span>,<span class="keyword">...</span>
0275     <span class="string">'String'</span>,<span class="string">'Recluster'</span>,<span class="keyword">...</span>
0276     <span class="string">'Position'</span>,[500,550,100,35],<span class="string">'value'</span>,0,<span class="keyword">...</span>
0277     <span class="string">'Call'</span>,@<a href="#_sub2" class="code" title="subfunction change_cluster(varargin)">change_cluster</a>);
0278 
0279 rows=ceil(length(property_names)/5);
0280 
0281 i=1;
0282 <span class="keyword">while</span> i&lt;=length(property_names)
0283     row=ceil(i/5);
0284     column=mod(i,5);
0285     <span class="keyword">if</span> column==0, column=5; <span class="keyword">end</span>
0286     cluster_data_check{i}=uicontrol(<span class="string">'Style'</span>,<span class="string">'checkbox'</span>,<span class="keyword">...</span>
0287         <span class="string">'String'</span>,property_names{i},<span class="keyword">...</span>
0288         <span class="string">'Value'</span>,i==1,<span class="string">'Position'</span>,[50+column*60,600-row*35,70,25]);
0289     set(cluster_data_check{i},<span class="string">'Units'</span>,<span class="string">'Normalized'</span>)
0290     i=i+1;
0291 <span class="keyword">end</span>
0292 
0293 <span class="comment">% now align everything and send the main_window handle to the output</span>
0294 <span class="comment">% so we can use the gui with uiwait (requires the handle as a return value)</span>
0295 
0296 align([pop_up_clusters,pop_up_clusters_text,push_replot_save],<span class="string">'Center'</span>,<span class="string">'None'</span>);
0297 align([pop_up_x,pop_up_x_text],<span class="string">'Center'</span>,<span class="string">'None'</span>);
0298 align([pop_up_y,pop_up_y_text],<span class="string">'Center'</span>,<span class="string">'None'</span>);
0299 align([pop_up_z,pop_up_z_text],<span class="string">'Center'</span>,<span class="string">'None'</span>);
0300 
0301 <a href="#_sub2" class="code" title="subfunction change_cluster(varargin)">change_cluster</a>();
0302 <a href="#_sub1" class="code" title="subfunction change_plot(varargin)">change_plot</a>();
0303 
0304 <span class="comment">% run change_plot, which updates the plot according to the defaults</span>
0305 
0306 set([main_window,plot_axis,pop_up_x,pop_up_x_text,pop_up_y,pop_up_y_text,pop_up_z,<span class="keyword">...</span>
0307     pop_up_z_text,pop_up_clusters,pop_up_clusters_text,<span class="keyword">...</span>
0308     push_replot_save,push_draw_mode,push_recluster],<span class="string">'Units'</span>,<span class="string">'Normalized'</span>);
0309 movegui(main_window,<span class="string">'center'</span>)
0310 
0311 set(main_window,<span class="string">'Visible'</span>,<span class="string">'On'</span>);
0312 
0313 
0314 
0315 uiwait(main_window);
0316 
0317 <span class="comment">%% Callbacks</span>
0318 
0319 <span class="comment">% this callback changes the plot and returns the sum of the distances</span>
0320 <span class="comment">% from the centroid for each point in a cluster</span>
0321 
0322 <span class="comment">% change the plot if we change any of our dimensions, DO NOT RECLUSTER!</span>
0323 
0324 <a name="_sub1" href="#_subfunctions" class="code">function change_plot(varargin)</a>
0325 
0326 <span class="comment">% get the number of dimensions for the plot (number of principal components)</span>
0327 
0328 cla;
0329 
0330 viewdim(1)=get(pop_up_x,<span class="string">'value'</span>);
0331 viewdim(2)=get(pop_up_y,<span class="string">'value'</span>);
0332 viewdim(3)=get(pop_up_z,<span class="string">'value'</span>);
0333 
0334 view_data=spike_data(:,viewdim);
0335 
0336 <span class="keyword">if</span> NDIMS==2
0337     <span class="keyword">for</span> i=1:CLUSTERS
0338         points=find(LABELS==i);
0339         h(:,i)=plot(view_data(points,1),view_data(points,2),<span class="keyword">...</span>
0340             <span class="string">'o'</span>,<span class="string">'markerfacecolor'</span>,colors{i},<span class="string">'markeredgecolor'</span>,<span class="string">'none'</span>);hold on
0341     <span class="keyword">end</span>
0342 
0343 <span class="keyword">else</span>
0344     <span class="keyword">for</span> i=1:CLUSTERS
0345         points=find(LABELS==i);
0346         h(:,i)=plot3(view_data(points,1),view_data(points,2),view_data(points,3),<span class="keyword">...</span>
0347             <span class="string">'o'</span>,<span class="string">'markerfacecolor'</span>,colors{i},<span class="string">'markeredgecolor'</span>,<span class="string">'none'</span>);hold on
0348 
0349     <span class="keyword">end</span>
0350 <span class="keyword">end</span>
0351 
0352 grid on
0353 view(NDIMS)
0354 
0355 xlabel(property_names{viewdim(1)});
0356 ylabel(property_names{viewdim(2)});
0357 zlabel(property_names{viewdim(3)});
0358 
0359 L=legend(h,LEGEND_LABELS,<span class="string">'Location'</span>,<span class="string">'NorthEastOutside'</span>);legend boxoff
0360 set(L,<span class="string">'FontSize'</span>,20,<span class="string">'FontName'</span>,<span class="string">'Helvetica'</span>)
0361 
0362 <span class="keyword">end</span>
0363 
0364 <a name="_sub2" href="#_subfunctions" class="code">function change_cluster(varargin)</a>
0365 
0366 <span class="comment">% label everything</span>
0367 <span class="comment">% use the dimensions ticked in the top box for clustering</span>
0368 
0369 dim=[];
0370 <span class="keyword">for</span> i=1:length(cluster_data_check)
0371 
0372     value=get(cluster_data_check{i},<span class="string">'Value'</span>);
0373 
0374     <span class="keyword">if</span> value
0375         dim=[dim i];
0376     <span class="keyword">end</span>
0377 
0378 <span class="keyword">end</span>
0379 
0380 draw_mode=get(push_draw_mode,<span class="string">'value'</span>);
0381 
0382 clusterchoices=get(pop_up_clusters,<span class="string">'string'</span>);
0383 clusterselection=get(pop_up_clusters,<span class="string">'value'</span>);
0384 
0385 clusterchoice=clusterchoices{clusterselection};
0386 
0387 <span class="comment">% perform the kmeans analysis and return the labels, centroid coordinates,</span>
0388 <span class="comment">% sum of all points in each cluster from their respective centroid and</span>
0389 <span class="comment">% the distance of all points from all centroids</span>
0390 
0391 <span class="comment">% start with one cluster, go up to 10 and check the within distance for all clusters</span>
0392 
0393 cluster_data=spike_data(:,dim);
0394 [datapoints,features]=size(spike_data);
0395 
0396 <span class="keyword">if</span> ~draw_mode
0397     options=statset(<span class="string">'Display'</span>,<span class="string">'off'</span>);
0398 
0399     clustnum=2:5;
0400     <span class="keyword">if</span> datapoints&lt;=features
0401         disp(<span class="string">'Too few spikes to fit'</span>);
0402         <span class="keyword">return</span>;
0403     <span class="keyword">end</span>
0404 
0405     <span class="comment">% gaussian mixture seems to work better than fcm</span>
0406 
0407     <span class="keyword">if</span> strcmp(lower(clusterchoice),<span class="string">'auto'</span>)
0408 
0409         parfor i=1:length(clustnum)
0410 
0411             testobj=gmdistribution.fit(cluster_data,clustnum(i),<span class="string">'Regularize'</span>,1,<span class="string">'Options'</span>,options);
0412             
0413             <span class="comment">%[center,u,obj_fcn]=fcm(cluster_data,clustnum(i),[NaN NaN NaN 0]);</span>
0414             
0415             <span class="comment">% compute the partition coefficient, simply all membership indices squared and summed</span>
0416 
0417             <span class="comment">%partition_coef(i)=sum(sum(u.^2))/datapoints;</span>
0418 
0419             AIC(i)=testobj.AIC;
0420             logl(i)=testobj.NlogL;
0421             disp([ num2str(clustnum(i)) <span class="string">' clusters'</span>]);
0422 
0423             <span class="comment">%disp(['Partition coefficient ' num2str(partition_coef(i))]);</span>
0424             disp([ <span class="string">'AIC '</span> num2str(testobj.AIC)]) <span class="comment">% Akaike information criterion</span>
0425             <span class="comment">%disp([ 'BIC ' num2str(testobj.BIC)]) % Bayes information criterion</span>
0426 
0427         <span class="keyword">end</span>
0428 
0429         [val,loc]=max(diff(diff(logl))); <span class="comment">% maximum derivative in log-likelihood over k</span>
0430         nclust=clustnum(loc);
0431         CLUSTERS=nclust;
0432 
0433     <span class="keyword">else</span>
0434         CLUSTERS=str2num(clusterchoice);
0435 
0436     <span class="keyword">end</span>
0437 
0438     disp([<span class="string">'Will use '</span> num2str(CLUSTERS) <span class="string">' clusters'</span>]);
0439 
0440     testobj=gmdistribution.fit(cluster_data,CLUSTERS,<span class="string">'Regularize'</span>,1,<span class="string">'Options'</span>,options);
0441     [idx,nlogl,P]=cluster(testobj,cluster_data);
0442     <span class="comment">%[center,u,obj_fcn]=fcm(cluster_data,CLUSTERS,[NaN NaN NaN 0]);</span>
0443 
0444     counter=1;
0445 
0446     <span class="keyword">for</span> i=1:datapoints
0447 
0448         <span class="comment">%[membership(i),idx(i)]=max(u(:,i)); % take posterior probability of the chosen cluster</span>
0449                             <span class="comment">% given observation i as the measure of &quot;membership&quot;</span>
0450         membership(i)=P(i,idx(i));
0451 
0452         <span class="keyword">if</span> membership(i)&lt;outlier_cutoff
0453             idx(i)=CLUSTERS+1; <span class="comment">% assign new &quot;junk cluster&quot;</span>
0454             counter=counter+1;
0455         <span class="keyword">end</span>
0456     <span class="keyword">end</span>
0457 
0458     disp([ num2str(counter) <span class="string">' outliers'</span>]);
0459 
0460     clusterlabels=unique(idx);
0461     CLUSTERS=length(clusterlabels);
0462 
0463     <span class="keyword">for</span> i=1:length(clusterlabels)
0464         idx(idx==clusterlabels(i))=i;    
0465     <span class="keyword">end</span>
0466 
0467     <span class="comment">% return labels, and windows and ISI sorted by cluster IDX</span>
0468 
0469     LABELS=idx;
0470     NDIMS=3;
0471 
0472     <span class="comment">% clear the plot axis</span>
0473 <span class="keyword">else</span>
0474 
0475     viewdim(1)=get(pop_up_x,<span class="string">'value'</span>);
0476     viewdim(2)=get(pop_up_y,<span class="string">'value'</span>);
0477 
0478     view_data=spike_data(:,viewdim);
0479 
0480     cla;
0481     LABELS=ones(datapoints,1);
0482     response=[];
0483     counter=2;
0484 
0485     plot(view_data(:,1),view_data(:,2),<span class="string">'o'</span>,<span class="string">'markerfacecolor'</span>,colors{1});view(2);
0486     hold on
0487     disp(<span class="string">'Select the corners of the enclosing polygon then press RETURN to continue...'</span>);
0488     hold off;
0489 
0490     <span class="keyword">while</span> isempty(response)
0491 
0492         [xv,yv]=ginput;
0493         k=convhull(xv,yv);    
0494         hold on;
0495         plot(xv(k),yv(k),<span class="string">'b-'</span>,<span class="string">'linewidth'</span>,1.25);
0496         choice=inpolygon(view_data(:,1),view_data(:,2),xv(k),yv(k));
0497         LABELS(choice==1)=counter;
0498         response=input(<span class="string">'(D)one clustering or (c)ontinue?  '</span>,<span class="string">'s'</span>);
0499 
0500         <span class="keyword">switch</span> lower(response)
0501             <span class="keyword">case</span> <span class="string">'d'</span>
0502                 <span class="keyword">break</span>;
0503             <span class="keyword">case</span> <span class="string">'c'</span>
0504                 response=[];
0505             <span class="keyword">otherwise</span>
0506                 response=[];
0507         <span class="keyword">end</span>
0508 
0509         counter=counter+1;
0510 
0511     <span class="keyword">end</span>
0512     
0513     CLUSTERS=counter;
0514     NDIMS=3;
0515 
0516 <span class="keyword">end</span>
0517 
0518 <span class="comment">% plot in either 2 or 3 dims</span>
0519 <span class="comment">% turns out plot is MUCH faster than scatter, changed accordingly...</span>
0520 
0521 LEGEND_LABELS={};
0522 <span class="keyword">for</span> i=1:CLUSTERS
0523     LEGEND_LABELS{i}=num2str(i);
0524 <span class="keyword">end</span>
0525 
0526 <span class="comment">% compute any other stats we want, ISI, etc...</span>
0527 
0528 [uniq_trial trial_boundary trial_group]=unique(trialnum);
0529 trial_boundary=[1;trial_boundary];
0530 
0531 <span class="keyword">for</span> i=1:CLUSTERS
0532 
0533     spikewintmp=spikewindows(:,LABELS==i,1);
0534 
0535     <span class="comment">% need to collect isi within trial, don't count the first spike!</span>
0536     
0537     spikeisitmp=[];
0538 
0539     <span class="keyword">for</span> j=1:length(uniq_trial)
0540         
0541         <span class="comment">% all spike times in this trial</span>
0542         
0543         currtrial=spiketimes(trial_boundary(j):trial_boundary(j+1));
0544 
0545         <span class="comment">% now all spike ids from this trial</span>
0546 
0547         currlabels=LABELS(trialnum==uniq_trial(j));
0548 
0549         <span class="comment">% spike times for this cluster</span>
0550 
0551         currtrial=currtrial(currlabels==i);
0552 
0553         currisi=(diff(currtrial)); <span class="comment">% isi in msec</span>
0554         spikeisitmp=[spikeisitmp;currisi(:)];
0555     <span class="keyword">end</span>
0556 
0557     ISI{i}=spikeisitmp;
0558     WINDOWS{i}=spikewintmp;
0559 
0560 <span class="keyword">end</span>
0561 
0562 <a href="#_sub1" class="code" title="subfunction change_plot(varargin)">change_plot</a>();
0563 
0564 <span class="keyword">end</span>    
0565 
0566 <a name="_sub3" href="#_subfunctions" class="code">function show_stats(varargin)</a>
0567 
0568 <span class="comment">% get the labels from the main_window</span>
0569 
0570 statfig=figure(<span class="string">'Visible'</span>,<span class="string">'off'</span>);
0571 
0572 counter=1;
0573 binedges=[0:.1:10];
0574 
0575 ymin=inf;
0576 ymax=-inf;
0577 
0578 <span class="keyword">for</span> i=1:CLUSTERS
0579 
0580     ax(i)=subplot(CLUSTERS,2,counter);
0581     [samples,trials]=size(WINDOWS{i});
0582 
0583     <span class="keyword">if</span> ~interpolate
0584         plot(([1:samples]./sr)*1e3,WINDOWS{i});
0585     <span class="keyword">else</span>        
0586         plot(([1:samples]./interpolate_fs)*1e3,WINDOWS{i});
0587     <span class="keyword">end</span>
0588 
0589     ylabel(<span class="string">'microvolts'</span>);
0590     xlabel(<span class="string">'msec'</span>);
0591     axis tight
0592     ylimits=ylim();
0593     
0594     <span class="keyword">if</span> ylimits(1)&lt;ymin
0595         ymin=ylimits(1);
0596     <span class="keyword">end</span>
0597     
0598     <span class="keyword">if</span> ylimits(2)&gt;ymax
0599         ymax=ylimits(2);
0600     <span class="keyword">end</span>
0601 
0602     <span class="comment">%[f,xi]=ksdensity(spikeisi);</span>
0603     
0604     xlimits=xlim();
0605     xlim([0 xlimits(2)]);
0606 
0607     counter=counter+1;
0608     ax2=subplot(CLUSTERS,2,counter);
0609     density=histc((ISI{i}/sr)*1e3,binedges);
0610     bar(binedges,density,<span class="string">'histc'</span>);
0611     xlabel(<span class="string">'ISI (msec)'</span>);
0612     ylabel(<span class="string">'N'</span>);
0613     xlim([binedges(1) binedges(end)]);
0614 
0615     counter=counter+1;
0616 <span class="keyword">end</span>
0617 
0618 linkaxes(ax,<span class="string">'xy'</span>);
0619 set(ax(1),<span class="string">'ylim'</span>,[ymin ymax]);
0620 linkaxes(ax2,<span class="string">'xy'</span>);
0621 
0622 set(statfig,<span class="string">'visible'</span>,<span class="string">'on'</span>);
0623 
0624 <span class="keyword">end</span>
0625 
0626 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 22-Jul-2012 12:37:58 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>