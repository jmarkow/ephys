<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ephys_spike_detect</title>
  <meta name="keywords" content="ephys_spike_detect">
  <meta name="description" content="ephys_spike_detect.m performs spike detection on a vector with a pre-determined">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../menu.html">Home</a> &gt;  <a href="../../menu.html">ephys</a> &gt; <a href="../menu.html">helpers</a> &gt; <a href="menu.html">ephys</a> &gt; ephys_spike_detect.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../menu.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="menu.html">Index for ephys/helpers/ephys&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>ephys_spike_detect
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>ephys_spike_detect.m performs spike detection on a vector with a pre-determined</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [SPIKES_PP SPIKES_PB]=ephys_spike_detect(DATA,THRESH,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">ephys_spike_detect.m performs spike detection on a vector with a pre-determined
threshold

 [SPIKES_PP SPIKES_PB]=spike_detect(DATA,sr,traces,THRESH)


 DATA
 sample x trace matrix of voltage recrordings (threshold crossings detected on the first column, the rest are slaved)

 sr
 sampling rate of the recording

 THRESH
 threshold for detecting spikes

 the following can be specified as a parameter/value pair

 shadow
 length between spikes in S, i.e. the censor period (default .001)

 window
 two element vector specifying the distance before and after the spike to store
 (default [.001 .001])

 method
 string specifying whether to use (p)ositive threshold crossings, (n), or (b) 

 visualize
 generate a figure to visualize spike detection results

 realign
 after spike detection, realign ('y' or 'n', defeault: 'y') to peak

 align
 alignment method (only applicable if realign=='y') ('min' for absolute minimum,
 'max' for absolute maximum and 'com' for center of mass about the minimum)

 OUTPUT

 SPIKES_PP
 array of structures (number of traces)

 SPIKES_PP.pos.times 
 pos going spike times (in samples) 

 SPIKES_PP.pos.values
 pos going spike values

 SPIKES_PP.pos.window
 pos going spike windows
 
 SPIKES_PP.neg, same as pos

 SPIKES_PP.abs, same as pos

 SPIKES_PB
 array of structures (number of traces)

 SPIKES_PB.pos.trains
 sample x trace matrix with binned spikes (each bin is 1 sample)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../ephys/analysis_scripts/greg_proc_data.html" class="code" title="function greg_proc_data()">greg_proc_data</a>	</li><li><a href="../../../ephys/ephys_visual_sua.html" class="code" title="function ephys_visual_sua(EPHYS_DATA,HISTOGRAM,CHANNELS,varargin)">ephys_visual_sua</a>	generates song-aligned single-unit rasters</li><li><a href="../../../ephys/pipeline/ephys_pipeline_candidate_su.html" class="code" title="function SNR=ephys_candidate_su(EPHYS_DATA,CHANNELS,varargin)">ephys_pipeline_candidate_su</a>	ephys_candidate_su.m approximates the SNR of channels by</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [SPIKES_PP SPIKES_PB]=ephys_spike_detect(DATA,THRESH,varargin)</a>
0002 <span class="comment">%ephys_spike_detect.m performs spike detection on a vector with a pre-determined</span>
0003 <span class="comment">%threshold</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% [SPIKES_PP SPIKES_PB]=spike_detect(DATA,sr,traces,THRESH)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% DATA</span>
0009 <span class="comment">% sample x trace matrix of voltage recrordings (threshold crossings detected on the first column, the rest are slaved)</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% sr</span>
0012 <span class="comment">% sampling rate of the recording</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% THRESH</span>
0015 <span class="comment">% threshold for detecting spikes</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% the following can be specified as a parameter/value pair</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% shadow</span>
0020 <span class="comment">% length between spikes in S, i.e. the censor period (default .001)</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% window</span>
0023 <span class="comment">% two element vector specifying the distance before and after the spike to store</span>
0024 <span class="comment">% (default [.001 .001])</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% method</span>
0027 <span class="comment">% string specifying whether to use (p)ositive threshold crossings, (n), or (b)</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% visualize</span>
0030 <span class="comment">% generate a figure to visualize spike detection results</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% realign</span>
0033 <span class="comment">% after spike detection, realign ('y' or 'n', defeault: 'y') to peak</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% align</span>
0036 <span class="comment">% alignment method (only applicable if realign=='y') ('min' for absolute minimum,</span>
0037 <span class="comment">% 'max' for absolute maximum and 'com' for center of mass about the minimum)</span>
0038 <span class="comment">%</span>
0039 <span class="comment">% OUTPUT</span>
0040 <span class="comment">%</span>
0041 <span class="comment">% SPIKES_PP</span>
0042 <span class="comment">% array of structures (number of traces)</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% SPIKES_PP.pos.times</span>
0045 <span class="comment">% pos going spike times (in samples)</span>
0046 <span class="comment">%</span>
0047 <span class="comment">% SPIKES_PP.pos.values</span>
0048 <span class="comment">% pos going spike values</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% SPIKES_PP.pos.window</span>
0051 <span class="comment">% pos going spike windows</span>
0052 <span class="comment">%</span>
0053 <span class="comment">% SPIKES_PP.neg, same as pos</span>
0054 <span class="comment">%</span>
0055 <span class="comment">% SPIKES_PP.abs, same as pos</span>
0056 <span class="comment">%</span>
0057 <span class="comment">% SPIKES_PB</span>
0058 <span class="comment">% array of structures (number of traces)</span>
0059 <span class="comment">%</span>
0060 <span class="comment">% SPIKES_PB.pos.trains</span>
0061 <span class="comment">% sample x trace matrix with binned spikes (each bin is 1 sample)</span>
0062 <span class="comment">%</span>
0063 
0064 <span class="comment">%DATA=DATA(:);</span>
0065 SPIKES_PP=[];
0066 SPIKES_PB=[];
0067 
0068 <span class="keyword">if</span> nargin&lt;1
0069     error(<span class="string">'Need the input data to continue!'</span>);
0070 <span class="keyword">end</span>
0071 
0072 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0073 
0074 <span class="comment">% input argument collection</span>
0075 
0076 shadow=.75e-3; <span class="comment">% minimum time between spikes, i.e. censor period</span>
0077            <span class="comment">% per Hill, Mehta and Kleinfeld (2011), 750 microseconds</span>
0078 window=[.0005 .0005]; <span class="comment">% how large of a window to grab, seconds before and after spike</span>
0079 method=<span class="string">'b'</span>;
0080 visualize=<span class="string">'y'</span>;
0081 sr=25e3;
0082 realign=<span class="string">'y'</span>;
0083 interpolate=<span class="string">'y'</span>; <span class="comment">% do we want to interpolate for realignment (default 'y');</span>
0084 interpolate_fs=50e3; <span class="comment">% what fs should we intepolate to? (50e3 has worked in my experience)</span>
0085 align=<span class="string">'min'</span>;
0086 
0087 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0088 
0089 nparams=length(varargin);
0090 
0091 <span class="keyword">if</span> mod(nparams,2)&gt;0
0092     error(<span class="string">'Parameters must be specified as parameter/value pairs!'</span>);
0093 <span class="keyword">end</span>
0094 
0095 <span class="keyword">for</span> i=1:2:nparams
0096     <span class="keyword">switch</span> lower(varargin{i})
0097         <span class="keyword">case</span> <span class="string">'shadow'</span>
0098             shadow=varargin{i+1};
0099         <span class="keyword">case</span> <span class="string">'window'</span>
0100             window=varargin{i+1};
0101         <span class="keyword">case</span> <span class="string">'sigma'</span>
0102             sigma=varargin{i+1};
0103         <span class="keyword">case</span> <span class="string">'method'</span>
0104             method=varargin{i+1};
0105         <span class="keyword">case</span> <span class="string">'visualize'</span>
0106             visualize=varargin{i+1};
0107         <span class="keyword">case</span> <span class="string">'sr'</span>
0108             sr=varargin{i+1};
0109         <span class="keyword">case</span> <span class="string">'interpolate'</span>
0110             interpolate=varargin{i+1};
0111         <span class="keyword">case</span> <span class="string">'interpolate_fs'</span>
0112             interpolate_fs=varargin{i+1};
0113         <span class="keyword">case</span> <span class="string">'align'</span>
0114             align=varargin{i+1};
0115         <span class="keyword">case</span> <span class="string">'tetrode_data'</span>
0116             tetrode_data=varargin{i+1};
0117     <span class="keyword">end</span>
0118 <span class="keyword">end</span>
0119 
0120 [samples,traces]=size(DATA);
0121 
0122 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0123 
0124 <span class="comment">% pre-allocate the binned output if the user wants it!</span>
0125 
0126 <span class="keyword">if</span> nargout&gt;1
0127     <span class="keyword">if</span> lower(method(1))==<span class="string">'p'</span> || lower(method(1))==<span class="string">'a'</span>
0128         SPIKES_PB.pos.trains=zeros(size(DATA(:,1)),<span class="string">'int8'</span>);
0129     <span class="keyword">end</span>
0130     
0131     <span class="keyword">if</span> lower(method(1))==<span class="string">'n'</span> || lower(method(1))==<span class="string">'a'</span>
0132         SPIKES_PB.neg.trains=zeros(size(DATA(:,1)),<span class="string">'int8'</span>);
0133     <span class="keyword">end</span>
0134 
0135     <span class="keyword">if</span> lower(method(1))==<span class="string">'b'</span> || lower(method(1))==<span class="string">'a'</span>
0136         SPIKES_PB.abs.trains=zeros(size(DATA(:,1)),<span class="string">'int8'</span>);
0137     <span class="keyword">end</span>
0138 <span class="keyword">end</span>
0139 
0140 <span class="comment">% specify the spike window in terms of samples</span>
0141 
0142 spike_window=round(window.*sr);
0143 spike_window_length=length(-spike_window(1):spike_window(2));
0144 
0145 <span class="keyword">if</span> lower(interpolate(1))==<span class="string">'y'</span>
0146     expansion=interpolate_fs/sr;
0147 <span class="keyword">end</span>
0148 
0149 <span class="comment">% collect the pos-going and neg-going spikes</span>
0150 
0151 <span class="keyword">if</span> lower(method(1))==<span class="string">'p'</span> || lower(method(1))==<span class="string">'a'</span>
0152 
0153     <span class="comment">% find our peaks</span>
0154     [pos_times]=find(DATA(:,1)&gt;THRESH)
0155     counter=1;
0156 
0157     SPIKES_PP.pos.times=[];
0158     SPIKES_PP.pos.values=[];
0159     SPIKES_PP.pos.windows=[];
0160 
0161     <span class="comment">% if we can get a spike window around the peak, then collect for output</span>
0162     counter=2;
0163     <span class="keyword">while</span> counter&lt;=length(pos_times)
0164         dtime=pos_times(counter)-pos_times(counter-1);
0165         <span class="keyword">if</span> dtime&lt;shadow*sr
0166             pos_times(counter)=[];
0167         <span class="keyword">else</span>
0168             counter=counter+1;
0169         <span class="keyword">end</span>
0170     <span class="keyword">end</span>
0171 
0172     counter=1;
0173     <span class="keyword">for</span> j=1:length(pos_times)
0174 
0175         <span class="keyword">if</span> pos_times(j)-spike_window(1)&gt;0 &amp;&amp; pos_times(j)+spike_window(2)&lt;length(DATA(:,1))
0176 
0177 
0178             <span class="comment">% find the absolute minimum (or max) and use as the spike peak for alignment</span>
0179 
0180             tmp_time=pos_times(j);
0181             tmp_window=DATA(tmp_time-spike_window(1):tmp_time+spike_window(2),1);
0182 
0183             <span class="comment">% upsample the window with sinc interpolation</span>
0184 
0185             timepoints=[1:length(tmp_window)]';
0186             samples=length(tmp_window);
0187 
0188             <span class="keyword">if</span> lower(interpolate(1))==<span class="string">'y'</span>
0189                 newtimepoints=linspace(1,samples,expansion*samples)';
0190 
0191                 <span class="comment">% sinc interpolation</span>
0192 
0193                 interp_window=sinc(newtimepoints(:,ones(size(timepoints)))-<span class="keyword">...</span>
0194                     timepoints(:,ones(size(newtimepoints)))')*tmp_window(:);
0195             <span class="keyword">else</span>
0196                 newtimepoints=timepoints;
0197                 interp_window=tmp_window;
0198             <span class="keyword">end</span>
0199 
0200             <span class="comment">% need to add escape hatch with no interpolate</span>
0201 
0202             <span class="comment">% align by com (center of mass), min or max</span>
0203 
0204             <span class="keyword">switch</span> lower(align)
0205 
0206                 <span class="keyword">case</span> <span class="string">'com'</span>
0207                     [val loc]=min(interp_window);
0208 
0209                     <span class="comment">% take the samples around the min peak and compute the</span>
0210                     <span class="comment">% COM</span>
0211 
0212                     compoints=[-4:4]';
0213 
0214                     <span class="keyword">if</span> loc-4&lt;1 | loc+4&gt;length(interp_window)
0215                         alignpoint=round(newtimepoints(loc));
0216                         <span class="keyword">continue</span>;
0217                     <span class="keyword">end</span>
0218 
0219                     com=sum(compoints.*abs(interp_window(loc-4:loc+4)))/sum(abs(interp_window(loc-4:loc+4)));
0220                     alignpoint=round(newtimepoints(round(loc+com)));
0221 
0222                 <span class="keyword">case</span> <span class="string">'min'</span>
0223                     [val loc]=min(interp_window);
0224                     alignpoint=round(newtimepoints(loc));
0225                 <span class="keyword">case</span> <span class="string">'max'</span>
0226                     [val loc]=max(interp_window);
0227                     alignpoint=round(newtimepoints(loc));
0228 
0229             <span class="keyword">end</span>
0230 
0231             new_time=alignpoint;
0232             new_time=pos_times(j)-spike_window(1)+(new_time-1);
0233 
0234             <span class="keyword">if</span> new_time-spike_window(1)&gt;0 &amp;&amp; new_time+spike_window(2)&lt;length(DATA)
0235 
0236                 SPIKES_PP.pos.times(counter)=new_time;
0237                 SPIKES_PP.pos.values(counter)=DATA(new_time,1);
0238                 
0239                 <span class="keyword">for</span> k=1:traces
0240                     SPIKES_PP.pos.windows(:,counter,k)=DATA(new_time-spike_window(1):new_time+spike_window(2),k);
0241                 <span class="keyword">end</span>
0242                 
0243                 counter=counter+1;
0244 
0245             <span class="keyword">end</span>
0246 
0247         <span class="keyword">end</span>
0248 
0249     <span class="keyword">end</span>
0250 
0251     counter=2;
0252     <span class="keyword">while</span> counter&lt;=length(SPIKES_PP.pos.times)
0253         dtime=SPIKES_PP.pos.times(counter)-SPIKES_PP.pos.times(counter-1);
0254         <span class="keyword">if</span> dtime&lt;shadow*sr
0255             SPIKES_PP.pos.times(counter)=[];
0256             SPIKES_PP.pos.values(counter)=[];
0257             SPIKES_PP.pos.windows(:,counter,:)=[];
0258         <span class="keyword">else</span>
0259             counter=counter+1;
0260         <span class="keyword">end</span>
0261     <span class="keyword">end</span>
0262 
0263 <span class="keyword">end</span>
0264 
0265 <span class="comment">% same principle applies here...</span>
0266 
0267 <span class="keyword">if</span> lower(method(1))==<span class="string">'n'</span> || lower(method(1))==<span class="string">'a'</span>
0268 
0269     [neg_times]=find(-DATA&gt;THRESH);    
0270     counter=1;
0271 
0272     SPIKES_PP.neg.times=[];
0273     SPIKES_PP.neg.values=[];
0274     SPIKES_PP.neg.windows=[];
0275 
0276     counter=2;
0277     <span class="keyword">while</span> counter&lt;=length(neg_times)
0278         dtime=neg_times(counter)-neg_times(counter-1);
0279         <span class="keyword">if</span> dtime&lt;shadow*sr
0280             neg_times(counter)=[];
0281         <span class="keyword">else</span>
0282             counter=counter+1;
0283         <span class="keyword">end</span>
0284     <span class="keyword">end</span>
0285 
0286     counter=1;
0287     <span class="keyword">for</span> j=1:length(neg_times)
0288 
0289         <span class="keyword">if</span> neg_times(j)-spike_window(1)&gt;0 &amp;&amp; neg_times(j)+spike_window(2)&lt;length(DATA(:,1))
0290 
0291 
0292             <span class="comment">% find the absolute minimum (or max) and use as the spike peak for alignment</span>
0293 
0294             tmp_time=neg_times(j);
0295             tmp_window=DATA(tmp_time-spike_window(1):tmp_time+spike_window(2),1);
0296 
0297             <span class="comment">% upsample the window with sinc interpolation</span>
0298 
0299             timepoints=[1:length(tmp_window)]';
0300             samples=length(tmp_window);
0301 
0302             <span class="keyword">if</span> lower(interpolate(1))==<span class="string">'y'</span>
0303                 newtimepoints=linspace(1,samples,expansion*samples)';
0304 
0305                 <span class="comment">% sinc interpolation</span>
0306 
0307                 interp_window=sinc(newtimepoints(:,ones(size(timepoints)))-<span class="keyword">...</span>
0308                     timepoints(:,ones(size(newtimepoints)))')*tmp_window(:);
0309             <span class="keyword">else</span>
0310                 newtimepoints=timepoints;
0311                 interp_window=tmp_window;
0312             <span class="keyword">end</span>
0313 
0314             <span class="comment">% need to add escape hatch with no interpolate</span>
0315 
0316             <span class="comment">% align by com (center of mass), min or max</span>
0317 
0318             <span class="keyword">switch</span> lower(align)
0319 
0320                 <span class="keyword">case</span> <span class="string">'com'</span>
0321 
0322                     [val loc]=min(interp_window);
0323 
0324                     <span class="comment">% take the samples around the min peak and compute the</span>
0325                     <span class="comment">% COM</span>
0326 
0327                     compoints=[-4:4]';
0328 
0329                     <span class="keyword">if</span> loc-4&lt;1 | loc+4&gt;length(interp_window)
0330                         alignpoint=round(newtimepoints(loc));
0331                         <span class="keyword">continue</span>;
0332                     <span class="keyword">end</span>
0333 
0334                     com=sum(compoints.*abs(interp_window(loc-4:loc+4)))/sum(abs(interp_window(loc-4:loc+4)));
0335                     alignpoint=round(newtimepoints(round(loc+com)));
0336 
0337                 <span class="keyword">case</span> <span class="string">'min'</span>
0338                     [val loc]=min(interp_window);
0339                     alignpoint=round(newtimepoints(loc));
0340                 <span class="keyword">case</span> <span class="string">'max'</span>
0341                     [val loc]=max(interp_window);
0342                     alignpoint=round(newtimepoints(loc));
0343 
0344             <span class="keyword">end</span>
0345 
0346             new_time=alignpoint;
0347             new_time=neg_times(j)-spike_window(1)+(new_time-1);
0348 
0349             <span class="keyword">if</span> new_time-spike_window(1)&gt;0 &amp;&amp; new_time+spike_window(2)&lt;length(DATA(:,1))
0350 
0351                 SPIKES_PP.neg.times(counter)=new_time;
0352                 SPIKES_PP.neg.values(counter)=DATA(new_time,1);
0353 
0354                 SPIKES_PP.neg.windows(:,counter,:)=DATA(new_time-spike_window(1):new_time+spike_window(2),:);
0355                 counter=counter+1;
0356 
0357             <span class="keyword">end</span>
0358 
0359         <span class="keyword">end</span>
0360     <span class="keyword">end</span>
0361 
0362     counter=2;
0363     <span class="keyword">while</span> counter&lt;=length(SPIKES_PP.neg.times)
0364         dtime=SPIKES_PP.neg.times(counter)-SPIKES_PP.neg.times(counter-1);
0365         <span class="keyword">if</span> dtime&lt;shadow*sr
0366             SPIKES_PP.neg.times(counter)=[];
0367             SPIKES_PP.neg.values(counter)=[];
0368             SPIKES_PP.neg.windows(:,counter,:)=[];
0369         <span class="keyword">else</span>
0370             counter=counter+1;
0371         <span class="keyword">end</span>
0372     <span class="keyword">end</span>
0373 
0374 
0375 <span class="keyword">end</span>
0376 
0377 <span class="keyword">if</span> lower(method(1))==<span class="string">'b'</span> || lower(method(1))==<span class="string">'a'</span>
0378 
0379     [abs_times]=find(abs(DATA)&gt;THRESH);
0380     nspikes=length(abs_times);
0381 
0382     <span class="comment">% censor period</span>
0383 
0384     counter=2;
0385     <span class="keyword">while</span> counter&lt;=length(abs_times)
0386         dtime=abs_times(counter)-abs_times(counter-1);
0387         <span class="keyword">if</span> dtime&lt;shadow*sr
0388             abs_times(counter)=[];
0389         <span class="keyword">else</span>
0390             counter=counter+1;
0391         <span class="keyword">end</span>
0392     <span class="keyword">end</span>
0393 
0394     SPIKES_PP.abs.times=zeros(1,nspikes);
0395     SPIKES_PP.abs.values=zeros(1,nspikes);
0396     SPIKES_PP.abs.windows=zeros(spike_window_length,nspikes,traces);
0397 
0398     counter=1;
0399     <span class="keyword">for</span> j=1:length(abs_times)
0400 
0401         <span class="keyword">if</span> abs_times(j)-spike_window(1)&gt;0 &amp;&amp; abs_times(j)+spike_window(2)&lt;length(DATA(:,1))
0402 
0403 
0404             <span class="comment">% find the absolute minimum (or max) and use as the spike peak for alignment</span>
0405 
0406             tmp_time=abs_times(j);
0407             tmp_window=DATA(tmp_time-spike_window(1):tmp_time+spike_window(2),1);
0408 
0409             <span class="comment">% upsample the window with sinc interpolation</span>
0410 
0411             timepoints=[1:length(tmp_window)]';
0412             samples=length(tmp_window);
0413 
0414             <span class="keyword">if</span> lower(interpolate(1))==<span class="string">'y'</span>
0415                 newtimepoints=linspace(1,samples,expansion*samples)';
0416 
0417                 <span class="comment">% sinc interpolation</span>
0418 
0419                 interp_window=sinc(newtimepoints(:,ones(size(timepoints)))-<span class="keyword">...</span>
0420                     timepoints(:,ones(size(newtimepoints)))')*tmp_window(:);
0421             <span class="keyword">else</span>
0422                 newtimepoints=timepoints;
0423                 interp_window=tmp_window;
0424             <span class="keyword">end</span>
0425 
0426             <span class="comment">% need to add escape hatch with no interpolate</span>
0427 
0428             <span class="comment">% align by com (center of mass), min or max</span>
0429 
0430             <span class="keyword">switch</span> lower(align)
0431 
0432                 <span class="keyword">case</span> <span class="string">'com'</span>
0433                     [val loc]=min(interp_window);
0434 
0435                     <span class="comment">% take the samples around the min peak and compute the</span>
0436                     <span class="comment">% COM</span>
0437 
0438                     compoints=[-4:4]';
0439 
0440                     <span class="keyword">if</span> loc-4&lt;1 | loc+4&gt;length(interp_window)
0441                         alignpoint=round(newtimepoints(loc));
0442                         <span class="keyword">continue</span>;
0443                     <span class="keyword">end</span>
0444 
0445                     com=sum(compoints.*abs(interp_window(loc-4:loc+4)))/sum(abs(interp_window(loc-4:loc+4)));
0446                     alignpoint=round(newtimepoints(round(loc+com)));
0447 
0448                     <span class="comment">%alignpoint=sum(newtimepoints.*abs(interp_window))/sum(abs(interp_window));</span>
0449                 <span class="keyword">case</span> <span class="string">'min'</span>
0450                     [val loc]=min(interp_window);
0451                     alignpoint=round(newtimepoints(loc));
0452                 <span class="keyword">case</span> <span class="string">'max'</span>
0453                     [val loc]=max(interp_window);
0454                     alignpoint=round(newtimepoints(loc));
0455 
0456             <span class="keyword">end</span>
0457 
0458             new_time=alignpoint;
0459             new_time=abs_times(j)-spike_window(1)+(new_time-1);
0460 
0461             <span class="keyword">if</span> new_time-spike_window(1)&gt;0 &amp;&amp; new_time+spike_window(2)&lt;length(DATA(:,1))
0462 
0463                 SPIKES_PP.abs.times(counter)=new_time;
0464                 SPIKES_PP.abs.values(counter)=DATA(new_time,1);
0465                 SPIKES_PP.abs.windows(1:spike_window_length,counter,1:traces)=<span class="keyword">...</span>
0466                     DATA(new_time-spike_window(1):new_time+spike_window(2),1:traces);
0467 
0468                 counter=counter+1;
0469 
0470             <span class="keyword">end</span>
0471 
0472         <span class="keyword">end</span>
0473     <span class="keyword">end</span>
0474 
0475     <span class="comment">% how much of array is left unused...</span>
0476 
0477     SPIKES_PP.abs.times(counter:nspikes)=[];
0478     SPIKES_PP.abs.values(counter:nspikes)=[];
0479     SPIKES_PP.abs.windows(:,counter:nspikes,:)=[];
0480 
0481     <span class="comment">% make sure we haven't made any alignments that violate the censor period</span>
0482 
0483     counter=2;
0484     <span class="keyword">while</span> counter&lt;=length(SPIKES_PP.abs.times)
0485         dtime=SPIKES_PP.abs.times(counter)-SPIKES_PP.abs.times(counter-1);
0486         <span class="keyword">if</span> dtime&lt;shadow*sr
0487             SPIKES_PP.abs.times(counter)=[];
0488             SPIKES_PP.abs.values(counter)=[];
0489             SPIKES_PP.abs.windows(:,counter,:)=[];
0490         <span class="keyword">else</span>
0491             counter=counter+1;
0492         <span class="keyword">end</span>
0493     <span class="keyword">end</span>
0494 
0495 
0496 <span class="keyword">end</span>
0497 
0498 <span class="comment">% if the user wants binned point processes, give them to him/her!</span>
0499 
0500 <span class="keyword">if</span> nargout&gt;1
0501     <span class="comment">% all of the spikes times are given as one, note that the bin size</span>
0502     <span class="comment">% here is ONE SAMPLE, hence we cannot have more than one spike in the bin</span>
0503 
0504     <span class="keyword">if</span> lower(method(1))==<span class="string">'p'</span> || lower(method(1))==<span class="string">'a'</span>
0505         SPIKES_PB.pos.trains(SPIKES_PP.pos.times)=1;
0506     <span class="keyword">end</span>
0507 
0508     <span class="keyword">if</span> lower(method(1))==<span class="string">'n'</span> || lower(method(1))==<span class="string">'a'</span>
0509         SPIKES_PB.neg.trains(SPIKES_PP.neg.times)=1;
0510     <span class="keyword">end</span>
0511 
0512     <span class="keyword">if</span> lower(method(1))==<span class="string">'b'</span> || lower(method(1))==<span class="string">'a'</span>
0513         SPIKES_PB.abs.trains(SPIKES_PP.abs.times)=1;
0514     <span class="keyword">end</span>
0515 
0516 <span class="keyword">end</span>
0517 
0518 <span class="comment">% visualize the voltage trace, threshold(s) and spikes</span>
0519 
0520 <span class="keyword">if</span> lower(visualize(1))==<span class="string">'y'</span>
0521 
0522     nsamples=length(DATA);
0523     figure();
0524     plot([1:nsamples]./sr,DATA,<span class="string">'b'</span>);hold on
0525     ylabel({<span class="string">'Voltage (in V)'</span>;[<span class="string">'Threshold (in V):  '</span> num2str(THRESH)]},<span class="string">'FontSize'</span>,13,<span class="string">'FontName'</span>,<span class="string">'Helvetica'</span>);
0526     xlabel(<span class="string">'T (in s)'</span>,<span class="string">'FontSize'</span>,13,<span class="string">'FontName'</span>,<span class="string">'Helvetica'</span>);
0527     plot([1:nsamples]./sr,ones(nsamples,1).*THRESH,<span class="string">'r'</span>);
0528     plot([1:nsamples]./sr,ones(nsamples,1).*-THRESH,<span class="string">'r'</span>);
0529 
0530     <span class="keyword">if</span> lower(method(1))==<span class="string">'p'</span> || lower(method(1))==<span class="string">'a'</span>
0531         plot(SPIKES_PP.pos.times/sr,SPIKES_PP.pos.values,<span class="string">'r*'</span>,<span class="string">'markersize'</span>,10);
0532     <span class="keyword">end</span>
0533 
0534     <span class="keyword">if</span> lower(method(1))==<span class="string">'n'</span>  || lower(method(1))==<span class="string">'a'</span>
0535         plot(SPIKES_PP.neg.times/sr,SPIKES_PP.neg.values,<span class="string">'k*'</span>,<span class="string">'markersize'</span>,10);
0536     <span class="keyword">end</span>
0537 
0538     <span class="keyword">if</span> lower(method(1))==<span class="string">'b'</span> || lower(method(1))==<span class="string">'a'</span>
0539         plot(SPIKES_PP.abs.times/sr,SPIKES_PP.abs.values,<span class="string">'b*'</span>,<span class="string">'markersize'</span>,10);
0540     <span class="keyword">end</span>
0541 
0542     set(gca,<span class="string">'FontSize'</span>,11,<span class="string">'FontName'</span>,<span class="string">'Helvetica'</span>)
0543     box off
0544 
0545 <span class="keyword">end</span>
0546</pre></div>
<hr><address>Generated on Sun 22-Jul-2012 12:37:58 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>