<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ephys_cluster</title>
  <meta name="keywords" content="ephys_cluster">
  <meta name="description" content="ephys_cluster.m takes extracted and aligned singing data generated by intan_songdet.m">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../menu.html">Home</a> &gt;  <a href="menu.html">ephys</a> &gt; ephys_cluster.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../menu.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="menu.html">Index for ephys&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>ephys_cluster
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>ephys_cluster.m takes extracted and aligned singing data generated by intan_songdet.m</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function ephys_cluster(DIR,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">ephys_cluster.m takes extracted and aligned singing data generated by intan_songdet.m
and extracts and align renditions of a template vocalization chosen by the user.

example:

ephys_cluster(pwd)

First the script prompts the user to create a directory or continue a
previous run, then
the user selects a .mat file that contains the template vocalization and is prompted to 
draw a bounding box around the template.  All of the sound files in the same directory
are checked for spectral similarity to the template, and the user then manually cuts clusters
to choose the cluster of sounds similar to the template (the cluster with a mean highest score
in the feature dimensions is the likeliest candidate).  Finally, the cluster is saved to 
a directory specified by the user in extracted_data.mat.  The results can be visualized with
ephys_visual_mua.m (for multi-unit data).


    ephys_cluster(DIR,varargin)
    
    DIR
    directory that contains the extracted files (default: pwd)

    the following may be specified as parameter/value pairs:

        SR
        sampling rate for aligned data (25e3, default Intan)

        min_f
        lowermost frequency for template spectrogram

        max_f
        uppermost frequency for template spectrogram
        
        colors
        colormap for template spectrogram

see also nidaq_songdet.m,<a href="ephys_visual_mua.html" class="code" title="function [MUA TIME LABEL HISTOGRAM]=ephys_visual_mua(EPHYS_DATA,HISTOGRAM,CHANNELS,varargin)">ephys_visual_mua</a>.m,<a href="ephys_visual_sua.html" class="code" title="function ephys_visual_sua(EPHYS_DATA,HISTOGRAM,CHANNELS,varargin)">ephys_visual_sua</a>.m</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../ephys/helpers/spectral/ephys_pipeline_smscore.html" class="code" title="function [features]=ephys_pipeline_smscore(s,sr,varargin)">ephys_pipeline_smscore</a>	</li><li><a href="../ephys/helpers/visualization/multi_fig_save.html" class="code" title="function multi_fig_save(fighandle,save_dir,filename,formats,varargin)">multi_fig_save</a>	</li><li><a href="../ephys/helpers/visualization/new_data_plotter.html" class="code" title="function output=new_data_plotter(DATAFILE,SAVEFILE)">new_data_plotter</a>	</li><li><a href="../ephys/helpers/visualization/pretty_sonogram.html" class="code" title="function [IMAGE,F,T]=pretty_sonogram(SIGNAL,SR,varargin)">pretty_sonogram</a>	</li><li><a href="../ephys/helpers/visualization/spectro_navigate.html" class="code" title="function [EXTRACTED_SOUND,EXTRACTED_IMAGE,TIME_POINTS]=spectro_navigate(DATA)">spectro_navigate</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function TEMPLATE=select_template(DIR)</a></li><li><a href="#_sub2" class="code">function sound_file_features(DIR,SOUND_FILES,N,OVERLAP,FILTER_SCALE,DOWNSAMPLING)</a></li><li><a href="#_sub3" class="code">function template_match(TEMPLATE,TARGET_FILES,SAVEFILE,TEMPLATESIZE)</a></li><li><a href="#_sub4" class="code">function [MIC_DATA EPHYS_DATA CHANNELS USED_FILENAMES]=extract_hits(SELECTED_PEAKS,FILENAMES,TEMPLATESIZE,SPECT_THRESH,TIME_RANGE,SR,N,OVERLAP,DOWNSAMPLING)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function ephys_cluster(DIR,varargin)</a>
0002 <span class="comment">%ephys_cluster.m takes extracted and aligned singing data generated by intan_songdet.m</span>
0003 <span class="comment">%and extracts and align renditions of a template vocalization chosen by the user.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%example:</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%ephys_cluster(pwd)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%First the script prompts the user to create a directory or continue a</span>
0010 <span class="comment">%previous run, then</span>
0011 <span class="comment">%the user selects a .mat file that contains the template vocalization and is prompted to</span>
0012 <span class="comment">%draw a bounding box around the template.  All of the sound files in the same directory</span>
0013 <span class="comment">%are checked for spectral similarity to the template, and the user then manually cuts clusters</span>
0014 <span class="comment">%to choose the cluster of sounds similar to the template (the cluster with a mean highest score</span>
0015 <span class="comment">%in the feature dimensions is the likeliest candidate).  Finally, the cluster is saved to</span>
0016 <span class="comment">%a directory specified by the user in extracted_data.mat.  The results can be visualized with</span>
0017 <span class="comment">%ephys_visual_mua.m (for multi-unit data).</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%</span>
0020 <span class="comment">%    ephys_cluster(DIR,varargin)</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%    DIR</span>
0023 <span class="comment">%    directory that contains the extracted files (default: pwd)</span>
0024 <span class="comment">%</span>
0025 <span class="comment">%    the following may be specified as parameter/value pairs:</span>
0026 <span class="comment">%</span>
0027 <span class="comment">%        SR</span>
0028 <span class="comment">%        sampling rate for aligned data (25e3, default Intan)</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%        min_f</span>
0031 <span class="comment">%        lowermost frequency for template spectrogram</span>
0032 <span class="comment">%</span>
0033 <span class="comment">%        max_f</span>
0034 <span class="comment">%        uppermost frequency for template spectrogram</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%        colors</span>
0037 <span class="comment">%        colormap for template spectrogram</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%see also nidaq_songdet.m,ephys_visual_mua.m,ephys_visual_sua.m</span>
0040 
0041 spect_thresh=.1; <span class="comment">% deprecated, this parameter is no longer used</span>
0042 SR=25e3; <span class="comment">% sampling</span>
0043 colors=<span class="string">'hot'</span>;
0044 min_f=1e3;
0045 max_f=16e3;
0046 time_range=[0 inf];
0047 subset=<span class="string">''</span>;
0048 
0049 <span class="comment">% smscore parameters, THESE MUST MATCH THE PIPELINE PARAMETERS IN EPHYS_PIPELINE.CFG, OTHERWISE</span>
0050 <span class="comment">% THE FEATURE COMPUTATION BETWEEN THE TEMPLATE AND CANDIDATE SOUNDS WILL NOT</span>
0051 <span class="comment">% BE APPROPRIATELY MATCHED</span>
0052 
0053 n=1024;
0054 overlap=1000;
0055 filter_scale=10;
0056 downsampling=5;
0057 
0058 <span class="comment">% parameter collection</span>
0059 
0060 <span class="comment">% should add an option to only process files from certain time windows</span>
0061 <span class="comment">% e.g. for directed singing</span>
0062 
0063 nparams=length(varargin);
0064 
0065 <span class="keyword">if</span> mod(nparams,2)&gt;0
0066     error(<span class="string">'Parameters must be specified as parameter/value pairs'</span>);
0067 <span class="keyword">end</span>
0068 
0069 <span class="keyword">for</span> i=1:2:nparams
0070     <span class="keyword">switch</span> lower(varargin{i})
0071         <span class="keyword">case</span> <span class="string">'spect_thresh'</span>
0072             spect_thresh=varargin{i+1};
0073         <span class="keyword">case</span> <span class="string">'sr'</span>
0074             SR=varargin{i+1};
0075         <span class="keyword">case</span> <span class="string">'colors'</span>
0076             colors=varargin{i+1};
0077         <span class="keyword">case</span> <span class="string">'masks'</span>
0078             masks=varargin{i+1};
0079         <span class="keyword">case</span> <span class="string">'time_range'</span>
0080             time_range=varargin{i+1};
0081         <span class="keyword">case</span> <span class="string">'subset'</span>
0082             subset=varargin{i+1};
0083     <span class="keyword">end</span>
0084 <span class="keyword">end</span>
0085 
0086 <span class="comment">% TODO features to read from config file, need to make this play nice with changes to smscore...</span>
0087 
0088 <span class="keyword">if</span> nargin&lt;1 | isempty(DIR)
0089     DIR=uigetdir(pwd,<span class="string">'Select the directory with .mat files to process...'</span>);
0090 <span class="keyword">end</span>
0091 
0092 prev_run_listing={};
0093 
0094 listing=dir(fullfile(DIR));
0095 
0096 <span class="comment">% all embedded directories could be previous runs</span>
0097 
0098 <span class="keyword">for</span> i=1:length(listing)
0099     <span class="keyword">if</span> listing(i).isdir
0100         prev_run_listing{end+1}=listing(i).name;
0101     <span class="keyword">end</span>
0102 <span class="keyword">end</span>
0103 
0104 proc_dir=[];
0105 
0106 <span class="comment">% are we checking for a previous run or starting a new one?</span>
0107 
0108 <span class="keyword">if</span> ~isempty(prev_run_listing)
0109     response=[];
0110     <span class="keyword">while</span> isempty(response)
0111         response=input(<span class="string">'Would you like to go to a (p)revious run or (c)reate a new one?  '</span>,<span class="string">'s'</span>);
0112         
0113         <span class="keyword">switch</span> lower(response(1))
0114 
0115             <span class="keyword">case</span> <span class="string">'p'</span>
0116                 dir_num=menu(<span class="string">'Which directory would you like to use?'</span>,prev_run_listing);
0117 
0118                 <span class="keyword">if</span> isempty(dir_num), <span class="keyword">continue</span>; <span class="keyword">end</span>
0119 
0120                 dir_name=prev_run_listing{dir_num};
0121                 proc_dir=fullfile(DIR,dir_name);
0122 
0123             <span class="keyword">case</span> <span class="string">'c'</span>
0124 
0125             <span class="keyword">otherwise</span>
0126                 response=[];
0127         <span class="keyword">end</span>
0128 
0129     <span class="keyword">end</span>
0130 <span class="keyword">end</span>
0131 
0132 <span class="keyword">if</span> isempty(proc_dir)
0133 
0134     dir_name=[];
0135 
0136     <span class="keyword">while</span> isempty(dir_name)
0137 
0138         dir_name=input(<span class="string">'What would you like to name the new directory?  '</span>,<span class="string">'s'</span>);
0139 
0140         <span class="keyword">if</span> exist(fullfile(DIR,dir_name),<span class="string">'dir'</span>)
0141             disp(<span class="string">'Directory exists!'</span>);
0142             dir_name=[];
0143         <span class="keyword">end</span>
0144 
0145     <span class="keyword">end</span>
0146 
0147     proc_dir=fullfile(DIR,[ dir_name <span class="string">'_MANUALCLUST'</span>]);
0148     mkdir(proc_dir);
0149 
0150 <span class="keyword">end</span>
0151 
0152 <span class="comment">% have we already extracted a template?</span>
0153 
0154 <span class="keyword">if</span> ~exist(fullfile(proc_dir,<span class="string">'template_data.mat'</span>),<span class="string">'file'</span>)
0155 
0156     TEMPLATE=<a href="#_sub1" class="code" title="subfunction TEMPLATE=select_template(DIR)">select_template</a>(fullfile(DIR));
0157 
0158     <span class="comment">% compute the features of the template</span>
0159 
0160     disp(<span class="string">'Computing the spectral features of the template'</span>);
0161     template_features=<a href="../ephys/helpers/spectral/ephys_pipeline_smscore.html" class="code" title="function [features]=ephys_pipeline_smscore(s,sr,varargin)">ephys_pipeline_smscore</a>(TEMPLATE,SR,<span class="keyword">...</span>
0162         <span class="string">'n'</span>,n,<span class="string">'overlap'</span>,overlap,<span class="string">'filter_scale'</span>,filter_scale,<span class="string">'downsampling'</span>,downsampling);
0163     save(fullfile(proc_dir,<span class="string">'template_data.mat'</span>),<span class="string">'TEMPLATE'</span>,<span class="string">'template_features'</span>);
0164 
0165 <span class="keyword">else</span>
0166     disp(<span class="string">'Loading stored template...'</span>);
0167     load(fullfile(proc_dir,<span class="string">'template_data.mat'</span>),<span class="string">'TEMPLATE'</span>);
0168     
0169     disp(<span class="string">'Computing the spectral features of the template'</span>);
0170     template_features=<a href="../ephys/helpers/spectral/ephys_pipeline_smscore.html" class="code" title="function [features]=ephys_pipeline_smscore(s,sr,varargin)">ephys_pipeline_smscore</a>(TEMPLATE,SR,<span class="keyword">...</span>
0171         <span class="string">'n'</span>,n,<span class="string">'overlap'</span>,overlap,<span class="string">'filter_scale'</span>,filter_scale,<span class="string">'downsampling'</span>,downsampling);
0172     save(fullfile(proc_dir,<span class="string">'template_data.mat'</span>),<span class="string">'TEMPLATE'</span>,<span class="string">'template_features'</span>);
0173 
0174 <span class="keyword">end</span>
0175 
0176 <span class="comment">% generate a nice sonogram of the selected template</span>
0177 
0178 template_fig=figure(<span class="string">'Visible'</span>,<span class="string">'off'</span>);
0179 [template_image,f,t]=<a href="../ephys/helpers/visualization/pretty_sonogram.html" class="code" title="function [IMAGE,F,T]=pretty_sonogram(SIGNAL,SR,varargin)">pretty_sonogram</a>(TEMPLATE,SR,<span class="string">'N'</span>,1024,<span class="string">'overlap'</span>,1000);
0180 
0181 startidx=max([find(f&lt;=min_f);1]);
0182 stopidx=min([find(f&gt;=max_f);length(f)]);
0183 
0184 imagesc(t,f(startidx:stopidx),template_image(startidx:stopidx,:));
0185 set(gca,<span class="string">'ydir'</span>,<span class="string">'normal'</span>);
0186 
0187 xlabel(<span class="string">'Time (in s)'</span>);
0188 ylabel(<span class="string">'Fs'</span>);
0189 colormap(colors);
0190 <a href="../ephys/helpers/visualization/multi_fig_save.html" class="code" title="function multi_fig_save(fighandle,save_dir,filename,formats,varargin)">multi_fig_save</a>(template_fig,proc_dir,<span class="string">'template'</span>,<span class="string">'png'</span>);
0191 
0192 close([template_fig]);
0193 
0194 <span class="comment">% get the template size so we can extract hits of the same size</span>
0195 
0196 [junk,templength]=size(template_features{1});
0197 templength=templength-1;
0198 
0199 <span class="comment">% have we computed the difference between the template and the sound data?</span>
0200 
0201 skip=0;
0202 response=[];
0203 <span class="keyword">if</span> exist(fullfile(proc_dir,<span class="string">'cluster_data.mat'</span>),<span class="string">'file'</span>)
0204     disp(<span class="string">'Looks like you have computed the scores before...'</span>);
0205 
0206     <span class="keyword">while</span> isempty(response)
0207         response=input(<span class="string">'Would you like to (r)ecompute or (s)kip to clustering?  '</span>,<span class="string">'s'</span>);    
0208         <span class="keyword">switch</span> (lower(response))
0209             <span class="keyword">case</span> <span class="string">'r'</span>
0210                 skip=0;
0211             <span class="keyword">case</span> <span class="string">'s'</span>
0212                 skip=1;
0213             <span class="keyword">otherwise</span>
0214                 response=[];
0215         <span class="keyword">end</span>
0216     <span class="keyword">end</span>
0217 <span class="keyword">end</span>
0218 
0219 <span class="comment">% if we haven't computed the scores, do it!</span>
0220 
0221 <span class="keyword">if</span> ~skip
0222 
0223     <span class="comment">% collect all of the relevant .mat files</span>
0224 
0225     pre_files_to_proc=dir(fullfile(DIR,<span class="string">'*.mat'</span>));
0226 
0227     <span class="keyword">for</span> i=1:length(pre_files_to_proc)
0228 
0229         <span class="keyword">if</span> ~isempty(findstr(<span class="string">'match_scores.mat'</span>,pre_files_to_proc(i).name))
0230             <span class="keyword">continue</span>;
0231         <span class="keyword">end</span>
0232 
0233         files_to_proc{i}=fullfile(DIR,pre_files_to_proc(i).name);
0234     <span class="keyword">end</span>
0235 
0236     disp(<span class="string">'Computing features for all sounds...'</span>);
0237 
0238     <a href="#_sub2" class="code" title="subfunction sound_file_features(DIR,SOUND_FILES,N,OVERLAP,FILTER_SCALE,DOWNSAMPLING)">sound_file_features</a>(DIR,files_to_proc,n,overlap,filter_scale,downsampling);
0239 
0240     disp(<span class="string">'Comparing sound files to the template...'</span>);
0241 
0242     <span class="comment">% take a subset if the user has passed the option</span>
0243     <span class="comment">%</span>
0244     
0245     <span class="keyword">if</span> length(subset)==1
0246         disp([<span class="string">'Will use '</span> num2str(subset*100) <span class="string">'% of the available files'</span>]);
0247         <span class="comment">%selection=randsample(1:length(files_to_proc),floor(length(files_to_proc)*subset));</span>
0248         <span class="comment">%selection=sort(selection);</span>
0249         selection=round(linspace(1,length(files_to_proc),<span class="keyword">...</span>
0250             floor(length(files_to_proc)*subset)));
0251         files_to_proc=files_to_proc(selection);
0252     <span class="keyword">elseif</span> length(subset&gt;1)
0253         disp(<span class="string">'Will use the user provided subset'</span>);
0254 
0255         subset(subset&gt;length(files_to_proc))=[];
0256         files_to_proc=files_to_proc(subset);
0257     <span class="keyword">end</span>
0258 
0259     <a href="#_sub3" class="code" title="subfunction template_match(TEMPLATE,TARGET_FILES,SAVEFILE,TEMPLATESIZE)">template_match</a>(template_features,files_to_proc,fullfile(proc_dir,<span class="string">'cluster_data.mat'</span>),templength);
0260 
0261 <span class="keyword">end</span>
0262 
0263 property_names={<span class="string">'cos'</span>,<span class="string">'derivx'</span>, <span class="string">'derivy'</span>, <span class="string">'amp'</span>,<span class="string">'product'</span>,<span class="string">'curvature'</span>};
0264 save(fullfile(proc_dir,<span class="string">'cluster_data.mat'</span>),<span class="string">'property_names'</span>,<span class="string">'proc_dir'</span>,<span class="string">'-append'</span>);
0265 
0266 <span class="comment">% do we need to cluster again?</span>
0267 
0268 skip=0;
0269 response=[];
0270 <span class="keyword">if</span> exist(fullfile(proc_dir,<span class="string">'cluster_results.mat'</span>),<span class="string">'file'</span>)
0271     disp(<span class="string">'Looks like you have clustered the data before..'</span>);
0272 
0273     <span class="keyword">while</span> isempty(response)
0274         response=input(<span class="string">'Would you like to (r)ecluster or (s)kip?  '</span>,<span class="string">'s'</span>);    
0275         <span class="keyword">switch</span> (lower(response))
0276             <span class="keyword">case</span> <span class="string">'r'</span>
0277                 skip=0;
0278             <span class="keyword">case</span> <span class="string">'s'</span>
0279                 skip=1;
0280             <span class="keyword">otherwise</span>
0281                 response=[];
0282         <span class="keyword">end</span>
0283     <span class="keyword">end</span>
0284 <span class="keyword">end</span>
0285 
0286 
0287 <span class="keyword">if</span> ~skip
0288     uiwait(<a href="../ephys/helpers/visualization/new_data_plotter.html" class="code" title="function output=new_data_plotter(DATAFILE,SAVEFILE)">new_data_plotter</a>(fullfile(proc_dir,<span class="string">'cluster_data.mat'</span>),fullfile(proc_dir,<span class="string">'cluster_results.mat'</span>)));
0289 <span class="keyword">end</span>
0290 
0291 load(fullfile(proc_dir,<span class="string">'cluster_results.mat'</span>),<span class="string">'sorted_syllable'</span>);
0292 load(fullfile(proc_dir,<span class="string">'cluster_data.mat'</span>),<span class="string">'filenames'</span>);
0293 
0294 act_templatesize=length(TEMPLATE);
0295 
0296 skip=0;
0297 response=[];
0298 <span class="keyword">if</span> exist(fullfile(proc_dir,<span class="string">'extracted_data.mat'</span>),<span class="string">'file'</span>)
0299     disp(<span class="string">'Looks like you have extracted the data before..'</span>);
0300 
0301     <span class="keyword">while</span> isempty(response)
0302         response=input(<span class="string">'Would you like to (r)eextract or (s)kip?  '</span>,<span class="string">'s'</span>);    
0303         <span class="keyword">switch</span> (lower(response))
0304             <span class="keyword">case</span> <span class="string">'r'</span>
0305                 skip=0;
0306             <span class="keyword">case</span> <span class="string">'s'</span>
0307                 skip=1;
0308             <span class="keyword">otherwise</span>
0309                 response=[];
0310         <span class="keyword">end</span>
0311     <span class="keyword">end</span>
0312 <span class="keyword">end</span>
0313 
0314 
0315 <span class="keyword">if</span> ~skip
0316     [mic_data ephys_data channels used_filenames]=<a href="#_sub4" class="code" title="subfunction [MIC_DATA EPHYS_DATA CHANNELS USED_FILENAMES]=extract_hits(SELECTED_PEAKS,FILENAMES,TEMPLATESIZE,SPECT_THRESH,TIME_RANGE,SR,N,OVERLAP,DOWNSAMPLING)">extract_hits</a>(sorted_syllable,filenames,<span class="keyword">...</span>
0317         act_templatesize,spect_thresh,time_range,SR,n,overlap,downsampling);
0318     save(fullfile(proc_dir,<span class="string">'extracted_data.mat'</span>),<span class="string">'used_filenames'</span>,<span class="string">'mic_data'</span>,<span class="string">'ephys_data'</span>,<span class="string">'time_range'</span>,<span class="string">'channels'</span>,<span class="string">'-v7.3'</span>);
0319 <span class="keyword">end</span>
0320 
0321 
0322 <span class="keyword">end</span>
0323 
0324 
0325 <span class="comment">%%%% small function for template selection</span>
0326 
0327 <a name="_sub1" href="#_subfunctions" class="code">function TEMPLATE=select_template(DIR)</a>
0328 
0329 pause(.001); <span class="comment">% inserting 1 msec pause since uigetfile does not always open without it, not sure why...</span>
0330 
0331 response=[];
0332 
0333 <span class="keyword">while</span> isempty(response)
0334     [filename,pathname]=uigetfile(<span class="string">'*.mat'</span>,<span class="string">'Pick a sound file to extract the template from'</span>,fullfile(DIR));
0335     load(fullfile(pathname,filename),<span class="string">'mic_data'</span>);
0336     TEMPLATE=<a href="../ephys/helpers/visualization/spectro_navigate.html" class="code" title="function [EXTRACTED_SOUND,EXTRACTED_IMAGE,TIME_POINTS]=spectro_navigate(DATA)">spectro_navigate</a>(mic_data);
0337 
0338     response2=[];
0339     <span class="keyword">while</span> isempty(response2)
0340         
0341         response2=input(<span class="string">'(C)ontinue with selected template or (s)elect another sound file?  '</span>,<span class="string">'s'</span>);
0342 
0343         <span class="keyword">switch</span> lower(response2(1))
0344             <span class="keyword">case</span> <span class="string">'c'</span>
0345                 response=1;
0346             <span class="keyword">case</span> <span class="string">'s'</span>
0347                 response=[];
0348             <span class="keyword">otherwise</span>
0349                 response2=[];
0350         <span class="keyword">end</span>
0351 
0352     <span class="keyword">end</span>
0353 <span class="keyword">end</span>
0354 
0355 <span class="keyword">end</span>
0356 
0357 <span class="comment">%%%%</span>
0358 
0359 <span class="comment">% function to compute the spectral features for all the pertinent wave files</span>
0360 
0361 <a name="_sub2" href="#_subfunctions" class="code">function sound_file_features(DIR,SOUND_FILES,N,OVERLAP,FILTER_SCALE,DOWNSAMPLING)</a>
0362 
0363 par_save = @(FILE,features) save([FILE],<span class="string">'features'</span>);
0364 
0365 <span class="keyword">if</span> ~exist(fullfile(DIR,<span class="string">'syllable_data'</span>),<span class="string">'dir'</span>)
0366     mkdir(fullfile(DIR,<span class="string">'syllable_data'</span>));
0367 <span class="keyword">end</span>
0368 
0369 parfor i=1:length(SOUND_FILES)
0370 
0371     input_file=SOUND_FILES{i};
0372     disp([input_file])
0373 
0374     [path,name,ext]=fileparts(input_file);
0375     output_file=fullfile(DIR,<span class="string">'syllable_data'</span>,[ name <span class="string">'_score.mat'</span>]);
0376 
0377     <span class="keyword">if</span> exist(output_file,<span class="string">'file'</span>), <span class="keyword">continue</span>; <span class="keyword">end</span>
0378 
0379     disp([<span class="string">'Computing features for '</span> input_file]);
0380 
0381     <span class="comment">% simply read in the file and score it</span>
0382 
0383     <span class="comment">% getfield hack to get around parfor errors</span>
0384 
0385     data=load(input_file,<span class="string">'mic_data'</span>,<span class="string">'fs'</span>);
0386     <span class="keyword">if</span> ~isfield(data,<span class="string">'mic_data'</span>)
0387         disp([<span class="string">'Problem encountered with '</span> input_file]);
0388         disp(<span class="string">'Skipping...'</span>);
0389         <span class="keyword">continue</span>;
0390     <span class="keyword">end</span>
0391     
0392     sound_data=data.mic_data;
0393     fs=data.fs;
0394 
0395     <span class="keyword">if</span> length(sound_data)&lt;N
0396         disp(<span class="string">'Sound extraction too short, skipping...'</span>);
0397         disp([input_file]);
0398         <span class="keyword">continue</span>;
0399     <span class="keyword">end</span>
0400 
0401     sound_features=<a href="../ephys/helpers/spectral/ephys_pipeline_smscore.html" class="code" title="function [features]=ephys_pipeline_smscore(s,sr,varargin)">ephys_pipeline_smscore</a>(sound_data,fs,<span class="keyword">...</span>
0402         <span class="string">'n'</span>,N,<span class="string">'overlap'</span>,OVERLAP,<span class="string">'filter_scale'</span>,FILTER_SCALE,<span class="string">'downsampling'</span>,DOWNSAMPLING);
0403 
0404     <span class="comment">% save for posterity's sake</span>
0405 
0406     par_save(output_file,sound_features);
0407 
0408 <span class="keyword">end</span>
0409 
0410 <span class="keyword">end</span>
0411 
0412 <span class="comment">%%%%</span>
0413 
0414 <a name="_sub3" href="#_subfunctions" class="code">function template_match(TEMPLATE,TARGET_FILES,SAVEFILE,TEMPLATESIZE)</a>
0415 
0416 <span class="comment">% do the template matching here...</span>
0417 
0418 <span class="comment">%disp('Comparing the target sounds to the template...');</span>
0419 
0420 parfor i=1:length(TARGET_FILES)
0421 
0422     <span class="comment">% load the features of the sound data</span>
0423 
0424     target=[];
0425 
0426     [path,name,ext]=fileparts(TARGET_FILES{i});
0427 
0428     input_file=fullfile(path,<span class="string">'syllable_data'</span>,[ name <span class="string">'_score.mat'</span>]);    
0429     
0430     <span class="keyword">try</span>
0431         target=getfield(load(input_file,<span class="string">'features'</span>),<span class="string">'features'</span>);
0432     <span class="keyword">catch</span>
0433         disp([<span class="string">'Troubling reading '</span> input_file]);
0434         <span class="keyword">continue</span>;
0435     <span class="keyword">end</span>
0436 
0437     [junk,targetlength]=size(target{1});
0438 
0439     score_temp={};
0440     temp_mat=[];
0441 
0442     <span class="keyword">for</span> j=1:length(target)
0443         score_temp{j}=[];
0444 
0445         <span class="keyword">for</span> k=1:targetlength-TEMPLATESIZE
0446             score_temp{j}=[score_temp{j} sum(sum(abs(target{j}(:,k:k+TEMPLATESIZE)-TEMPLATE{j})))];
0447         <span class="keyword">end</span>
0448 
0449         score_temp{j}=score_temp{j}-mean(score_temp{j});
0450         score_temp{j}=score_temp{j}/std(score_temp{j});
0451         score_temp{j}(score_temp{j}&gt;0)=0;
0452         score_temp{j}=abs(score_temp{j});
0453 
0454     <span class="keyword">end</span>
0455 
0456     attributes=length(score_temp);
0457     product_score=score_temp{1};
0458     
0459     <span class="keyword">for</span> j=2:attributes, product_score=product_score.*score_temp{j}; <span class="keyword">end</span>
0460 
0461     <span class="keyword">if</span> length(product_score)&lt;3
0462         variableCellArray{i}=temp_mat;
0463         peakLocation{i}=[];
0464         <span class="keyword">continue</span>;
0465     <span class="keyword">end</span>
0466 
0467     [pks,locs]=findpeaks(product_score,<span class="string">'MINPEAKHEIGHT'</span>,.005);
0468 
0469     <span class="keyword">if</span> isempty(locs)
0470         variableCellArray{i}=temp_mat;
0471         peakLocation{i}=[];
0472         <span class="keyword">continue</span>; 
0473     <span class="keyword">end</span>
0474 
0475     curvature=gradient(gradient(product_score));
0476 
0477     <span class="keyword">for</span> j=1:attributes, temp_mat(:,j)=log(score_temp{j}(locs)); <span class="keyword">end</span>
0478 
0479     temp_mat(:,attributes+1)=log(product_score(locs));
0480     temp_mat(:,attributes+2)=log(abs(curvature(locs)));
0481 
0482     peakLocation{i}=locs;
0483     variableCellArray{i}=temp_mat;
0484 
0485 <span class="keyword">end</span>
0486 
0487 filenames=TARGET_FILES;
0488 
0489 empty_coords=find(cellfun(@isempty,variableCellArray));
0490 variableCellArray(empty_coords)=[];
0491 peakLocation(empty_coords)=[];
0492 filenames(empty_coords)=[];
0493 
0494 disp([length(variableCellArray)]);
0495 
0496 save(SAVEFILE,<span class="string">'variableCellArray'</span>,<span class="string">'peakLocation'</span>,<span class="string">'filenames'</span>);
0497 
0498 <span class="keyword">end</span>
0499 
0500 <span class="comment">%%%% the grand finale, extract the data!</span>
0501 
0502 <span class="comment">% need to adapt to grab aligned sound data in a sample x trials matrix</span>
0503 <span class="comment">% and a cell array of matrices for the Intan data (aligned for each electrodes)</span>
0504 <span class="comment">%</span>
0505 <span class="comment">%</span>
0506 
0507 <a name="_sub4" href="#_subfunctions" class="code">function [MIC_DATA EPHYS_DATA CHANNELS USED_FILENAMES]=extract_hits(SELECTED_PEAKS,FILENAMES,TEMPLATESIZE,SPECT_THRESH,TIME_RANGE,SR,N,OVERLAP,DOWNSAMPLING)</a>
0508 
0509 TEMPLATESIZE=TEMPLATESIZE+N;
0510 USED_FILENAMES={};
0511 MIC_DATA=[];
0512 
0513 load(FILENAMES{1});
0514 
0515 <span class="keyword">if</span> ~exist(<span class="string">'channels'</span>,<span class="string">'var'</span>);
0516     [samples,nchannels]=size(ephys_data);
0517     CHANNELS=1:nchannels;
0518 <span class="keyword">else</span>
0519     CHANNELS=channels;
0520 <span class="keyword">end</span>
0521 
0522 disp([<span class="string">'Extracting cluster ('</span> num2str(length(SELECTED_PEAKS)) <span class="string">' peaks):   '</span>]);
0523 disp(<span class="string">'Preallocating matrices...'</span>);
0524 
0525 formatstring=progressbar(length(SELECTED_PEAKS));
0526 counter=0;
0527 
0528 parfor i=1:length(SELECTED_PEAKS)
0529 
0530     <span class="keyword">if</span> length(SELECTED_PEAKS{i})&lt;1
0531         <span class="keyword">continue</span>;
0532     <span class="keyword">end</span>
0533 
0534     data=load(FILENAMES{i});
0535     sound_data=single(data.mic_data);
0536     
0537     <span class="keyword">if</span> ~isfield(data,<span class="string">'ephys_data'</span>)
0538         ephys_data=data.intan_data;
0539     <span class="keyword">else</span>
0540         ephys_data=data.ephys_data;
0541         <span class="keyword">end</span>
0542     
0543         channels=data.channels;
0544 
0545         <span class="keyword">if</span> ~isempty(setdiff(CHANNELS,channels)) || ~isempty(setdiff(channels,CHANNELS))
0546         disp([<span class="string">'Channel mismatch '</span> FILENAMES{i}]);
0547             <span class="keyword">continue</span>;
0548         <span class="keyword">end</span>
0549     
0550     
0551     fs=data.fs;
0552     <span class="keyword">for</span> j=1:length(SELECTED_PEAKS{i})
0553         
0554         peakLoc=SELECTED_PEAKS{i}(j);
0555 
0556         <span class="comment">% the startpoint needs to be adjusted using the following formula</span>
0557         <span class="comment">% peaklocation*(WINDOWLENGTH-OVERLAP)*SUBSAMPLING-WINDOWLENGTH</span>
0558 
0559         startpoint=(peakLoc*(N-OVERLAP)*DOWNSAMPLING)-N;
0560         endpoint=startpoint+TEMPLATESIZE;
0561 
0562         <span class="keyword">if</span> startpoint/SR&gt;=TIME_RANGE(1) &amp; endpoint/SR&lt;=TIME_RANGE(2)
0563 
0564             <span class="keyword">if</span> length(sound_data)&gt;endpoint &amp;&amp; startpoint&gt;0
0565                 
0566                 counter=counter+1;
0567             
0568             <span class="keyword">end</span>
0569 
0570         <span class="keyword">end</span>
0571     <span class="keyword">end</span>
0572 <span class="keyword">end</span>
0573 
0574 disp([<span class="string">'Found '</span> num2str(counter) <span class="string">' trials '</span>]);
0575 fprintf(1,<span class="string">'\n'</span>);
0576 
0577 <span class="comment">%%%%</span>
0578 
0579 EPHYS_DATA=zeros(TEMPLATESIZE+1,counter,length(CHANNELS),<span class="string">'single'</span>);
0580 MIC_DATA=zeros(TEMPLATESIZE+1,counter,<span class="string">'single'</span>);
0581 
0582 disp(<span class="string">'Extracting data'</span>);
0583 fprintf(1,<span class="string">'\n\n\n\n\n\n'</span>);
0584 
0585 trial=1;
0586 <span class="keyword">for</span> i=1:length(SELECTED_PEAKS)
0587 
0588     fprintf(1,formatstring,i);
0589 
0590     <span class="keyword">if</span> length(SELECTED_PEAKS{i})&lt;1
0591         <span class="keyword">continue</span>;
0592     <span class="keyword">end</span>
0593 
0594     data=load(FILENAMES{i});
0595     sound_data=single(data.mic_data);
0596     
0597     <span class="keyword">if</span> ~isfield(data,<span class="string">'ephys_data'</span>)
0598         ephys_data=data.intan_data;
0599     <span class="keyword">else</span>
0600         ephys_data=data.ephys_data;
0601         <span class="keyword">end</span>
0602      
0603     fs=data.fs;
0604     <span class="keyword">for</span> j=1:length(SELECTED_PEAKS{i})
0605         
0606         peakLoc=SELECTED_PEAKS{i}(j);
0607 
0608         <span class="comment">% the startpoint needs to be adjusted using the following formula</span>
0609         <span class="comment">% peaklocation*(WINDOWLENGTH-OVERLAP)*SUBSAMPLING-WINDOWLENGTH</span>
0610 
0611         startpoint=(peakLoc*(N-OVERLAP)*DOWNSAMPLING)-N;
0612         endpoint=startpoint+TEMPLATESIZE;
0613 
0614         <span class="keyword">if</span> startpoint/SR&gt;=TIME_RANGE(1) &amp; endpoint/SR&lt;=TIME_RANGE(2)
0615 
0616             <span class="keyword">if</span> length(sound_data)&gt;endpoint &amp;&amp; startpoint&gt;0
0617 
0618                 USED_FILENAMES{end+1}=FILENAMES{i};
0619                         MIC_DATA(:,trial)=single(sound_data(startpoint:endpoint));               
0620                 
0621                 <span class="comment">% if we have differences in channel number, how to resolve?</span>
0622 
0623                 <span class="keyword">for</span> k=1:length(CHANNELS)
0624                     
0625                     EPHYS_DATA(:,trial,k)=single(ephys_data(startpoint:endpoint,k));
0626 
0627                 <span class="keyword">end</span>
0628 
0629                 trial=trial+1;
0630 
0631             <span class="keyword">end</span>
0632 
0633         <span class="keyword">end</span>
0634     <span class="keyword">end</span>
0635 <span class="keyword">end</span>
0636 
0637 fprintf(<span class="string">'\n'</span>);
0638 
0639 <span class="keyword">end</span>
0640</pre></div>
<hr><address>Generated on Thu 19-Jul-2012 21:29:37 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>